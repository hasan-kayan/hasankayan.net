(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["rive"] = factory();
	else
		root["rive"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var Rive = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  
  return (
function(moduleArg = {}) {

var k=moduleArg,aa,ba;k.ready=new Promise((a,b)=>{aa=a;ba=b});
function ca(){function a(g){const h=d;c=b=0;d=new Map;h.forEach(m=>{try{m(g)}catch(p){console.error(p)}});this.fe();e&&e.ye()}let b=0,c=0,d=new Map,e=null,f=null;this.requestAnimationFrame=function(g){b||(b=requestAnimationFrame(a.bind(this)));const h=++c;d.set(h,g);return h};this.cancelAnimationFrame=function(g){d.delete(g);b&&0==d.size&&(cancelAnimationFrame(b),b=0)};this.ve=function(g){f&&(document.body.remove(f),f=null);g||(f=document.createElement("div"),f.style.backgroundColor="black",f.style.position=
"fixed",f.style.right=0,f.style.top=0,f.style.color="white",f.style.padding="4px",f.innerHTML="RIVE FPS",g=function(h){f.innerHTML="RIVE FPS "+h.toFixed(1)},document.body.appendChild(f));e=new function(){let h=0,m=0;this.ye=function(){var p=performance.now();m?(++h,p-=m,1E3<p&&(g(1E3*h/p),h=m=0)):(m=p,h=0)}}};this.fe=function(){}}
function da(){console.assert(!0);const a=new Map;let b=-Infinity;this.push=function(c){c=c+255>>8;a.has(c)&&clearTimeout(a.get(c));a.set(c,setTimeout(function(){a.delete(c);0==a.length?b=-Infinity:c==b&&(b=Math.max(...a.keys()),console.assert(b<c))},1E3));b=Math.max(c,b);return b<<8}}
k.onRuntimeInitialized=function(){function a(l){this.ld=l;this.ke=l.getContext("2d");this.oe=e;this.qd=[];this.Bd=0;this.clear=function(){console.assert(0==this.Bd);this.qd=[];f.delete(this)};this.save=function(){++this.Bd;this.qd.push(e.save.bind(e))};this.restore=function(){0<this.Bd&&(this.qd.push(e.restore.bind(e)),--this.Bd)};this.transform=function(q){this.qd.push(e.transform.bind(e,q))};this.align=function(q,u,x,E){this.qd.push(e.align.bind(e,q,u,x,E))};this.flush=function(){console.assert(0==
this.Bd);f.add(this);d&&c()}}function b(l){var q={alpha:1,depth:0,stencil:8,antialias:0,premultipliedAlpha:1,preserveDrawingBuffer:0,preferLowPowerToHighPerformance:0,failIfMajorPerformanceCaveat:0,enableExtensionsByDefault:1,explicitSwapControl:0,renderViaOffscreenBackBuffer:0},u=l.getContext("webgl2",q);u||(u=l.getContext("webgl",q));var x=u,E=ea(fa),B={handle:E,attributes:q,version:q.Ue,Pd:x};x.canvas&&(x.canvas.Te=B);fa[E]=B;("undefined"==typeof q.ue||q.ue)&&ha(B);n=fa[E];k.qe=t=n&&n.Pd;q=g(l.width,
l.height);q.me=E;q.ld=l;q.Yd=l.width;q.Xd=l.height;q.le=u;return q}function c(){if(e){var l=e.ne,q=0,u=0,x=0,E=Array(f.size),B=0;for(var F of f)F.yd=Math.min(F.ld.width,l),F.xd=Math.min(F.ld.height,l),F.Qd=F.xd*F.yd,q=Math.max(q,F.yd),u=Math.max(u,F.xd),x+=F.Qd,E[B++]=F;f.clear();if(!(0>=x)){q=1<<(0>=q?0:32-Math.clz32(q-1));for(u=1<<(0>=u?0:32-Math.clz32(u-1));u*q<x;)q<=u?q*=2:u*=2;q=Math.min(q,l);q=Math.min(u,l);E.sort((Y,cb)=>cb.Qd-Y.Qd);x=new k.DynamicRectanizer(l);for(F=0;F<E.length;){x.reset(q,
u);for(B=F;B<E.length;++B){var J=E[B],G=x.addRect(J.yd,J.xd);if(0>G){console.assert(B>F);break}J.Fd=G&65535;J.Gd=G>>16}J=m.push(x.drawWidth());G=p.push(x.drawHeight());console.assert(J>=x.drawWidth());console.assert(G>=x.drawHeight());console.assert(J<=l);console.assert(G<=l);e.ld.width!=J&&(e.ld.width=J);e.ld.height!=G&&(e.ld.height=G);e.clear();for(J=F;J<B;++J){G=E[J];e.saveClipRect(G.Fd,G.Gd,G.Fd+G.yd,G.Gd+G.xd);let Y=new k.Mat2D;Y.xx=G.yd/G.ld.width;Y.yy=G.xd/G.ld.height;Y.xy=Y.yx=0;Y.tx=G.Fd;
Y.ty=G.Gd;e.transform(Y);for(const cb of G.qd)cb();e.restoreClipRect();G.qd=[]}for(e.flush();F<B;++F)J=E[F],G=J.ke,G.globalCompositeOperation="copy",G.drawImage(e.ld,J.Fd,J.Gd,J.yd,J.xd,0,0,J.ld.width,J.ld.height);F=B}}}}const d=navigator.userAgent.match(/firefox|fxios/i);let e=null;const f=new Set,g=k.makeRenderer;k.makeRenderer=function(l,q){return q?(e||(e=b(document.createElement("canvas")),q=e.le,e.ne=Math.min(q.getParameter(q.MAX_RENDERBUFFER_SIZE),q.getParameter(q.MAX_TEXTURE_SIZE))),new a(l)):
b(l)};const h=k.Artboard.prototype.draw;k.Artboard.prototype.draw=function(l){l.qd?l.qd.push(h.bind(this,l.oe)):h.call(this,l)};const m=new da,p=new da,r=new ca;k.requestAnimationFrame=r.requestAnimationFrame.bind(r);k.cancelAnimationFrame=r.cancelAnimationFrame.bind(r);k.enableFPSCounter=r.ve.bind(r);r.fe=c;let v=k.load;k.load=function(l){return Promise.resolve(v(l))};const z=k.WebGLRenderer.prototype.clear;k.WebGLRenderer.prototype.clear=function(){n=fa[this.me];k.qe=t=n&&n.Pd;const l=this.ld;if(this.Yd!=
l.width||this.Xd!=l.height)this.resize(l.width,l.height),this.Yd=l.width,this.Xd=l.height;z.call(this)}};var ia=Object.assign({},k),ja="./this.program",ka="object"==typeof window,la="function"==typeof importScripts,w="",ma,na;
if(ka||la)la?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),0!==w.indexOf("blob:")?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",la&&(na=a=>{var b=new XMLHttpRequest;b.open("GET",a,!1);b.responseType="arraybuffer";b.send(null);return new Uint8Array(b.response)}),ma=(a,b,c)=>{var d=new XMLHttpRequest;d.open("GET",a,!0);d.responseType="arraybuffer";d.onload=()=>{200==d.status||0==d.status&&d.response?
b(d.response):c()};d.onerror=c;d.send(null)};var oa=k.print||console.log.bind(console),pa=k.printErr||console.error.bind(console);Object.assign(k,ia);ia=null;k.thisProgram&&(ja=k.thisProgram);var qa;k.wasmBinary&&(qa=k.wasmBinary);var noExitRuntime=k.noExitRuntime||!0;"object"!=typeof WebAssembly&&ra("no native wasm support detected");var sa,y,ta=!1,ua,A,va,wa,C,D,H,xa;
function ya(){var a=sa.buffer;k.HEAP8=ua=new Int8Array(a);k.HEAP16=va=new Int16Array(a);k.HEAP32=C=new Int32Array(a);k.HEAPU8=A=new Uint8Array(a);k.HEAPU16=wa=new Uint16Array(a);k.HEAPU32=D=new Uint32Array(a);k.HEAPF32=H=new Float32Array(a);k.HEAPF64=xa=new Float64Array(a)}var I,za=[],Aa=[],Ba=[];function Ca(){var a=k.preRun.shift();za.unshift(a)}var Da=0,Ea=null,Fa=null;
function ra(a){if(k.onAbort)k.onAbort(a);a="Aborted("+a+")";pa(a);ta=!0;a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info.");ba(a);throw a;}function Ga(a){return a.startsWith("data:application/octet-stream;base64,")}var Ha;Ha="webgl_advanced.wasm";if(!Ga(Ha)){var Ia=Ha;Ha=k.locateFile?k.locateFile(Ia,w):w+Ia}function Ja(a){if(a==Ha&&qa)return new Uint8Array(qa);if(na)return na(a);throw"both async and sync fetching of the wasm failed";}
function Ka(a){if(!qa&&(ka||la)){if("function"==typeof fetch&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then(b=>{if(!b.ok)throw"failed to load wasm binary file at '"+a+"'";return b.arrayBuffer()}).catch(()=>Ja(a));if(ma)return new Promise((b,c)=>{ma(a,d=>b(new Uint8Array(d)),c)})}return Promise.resolve().then(()=>Ja(a))}function La(a,b,c){return Ka(a).then(d=>WebAssembly.instantiate(d,b)).then(d=>d).then(c,d=>{pa("failed to asynchronously prepare wasm: "+d);ra(d)})}
function Ma(a,b){var c=Ha;return qa||"function"!=typeof WebAssembly.instantiateStreaming||Ga(c)||c.startsWith("file://")||"function"!=typeof fetch?La(c,a,b):fetch(c,{credentials:"same-origin"}).then(d=>WebAssembly.instantiateStreaming(d,a).then(b,function(e){pa("wasm streaming compile failed: "+e);pa("falling back to ArrayBuffer instantiation");return La(c,a,b)}))}var Na=a=>{for(;0<a.length;)a.shift()(k)},Oa={};function Pa(a){for(;a.length;){var b=a.pop();a.pop()(b)}}
function Qa(a){return this.fromWireType(C[a>>2])}var Ra={},Sa={},Ta={},Ua=void 0;function Va(a){throw new Ua(a);}function K(a,b,c){function d(h){h=c(h);h.length!==a.length&&Va("Mismatched type converter count");for(var m=0;m<a.length;++m)L(a[m],h[m])}a.forEach(function(h){Ta[h]=b});var e=Array(b.length),f=[],g=0;b.forEach((h,m)=>{Sa.hasOwnProperty(h)?e[m]=Sa[h]:(f.push(h),Ra.hasOwnProperty(h)||(Ra[h]=[]),Ra[h].push(()=>{e[m]=Sa[h];++g;g===f.length&&d(e)}))});0===f.length&&d(e)}
function Wa(a){switch(a){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(`Unknown type size: ${a}`);}}var Xa=void 0;function M(a){for(var b="";A[a];)b+=Xa[A[a++]];return b}var Ya=void 0;function N(a){throw new Ya(a);}
function Za(a,b,c={}){var d=b.name;a||N(`type "${d}" must have a positive integer typeid pointer`);if(Sa.hasOwnProperty(a)){if(c.Fe)return;N(`Cannot register type '${d}' twice`)}Sa[a]=b;delete Ta[a];Ra.hasOwnProperty(a)&&(b=Ra[a],delete Ra[a],b.forEach(e=>e()))}function L(a,b,c={}){if(!("argPackAdvance"in b))throw new TypeError("registerType registeredInstance requires argPackAdvance");Za(a,b,c)}function $a(a){N(a.ed.hd.fd.name+" instance already deleted")}var ab=!1;function bb(){}
function db(a){--a.count.value;0===a.count.value&&(a.md?a.od.sd(a.md):a.hd.fd.sd(a.gd))}function eb(a,b,c){if(b===c)return a;if(void 0===c.jd)return null;a=eb(a,b,c.jd);return null===a?null:c.te(a)}var fb={},gb=[];function hb(){for(;gb.length;){var a=gb.pop();a.ed.Ad=!1;a["delete"]()}}var ib=void 0,jb={};function kb(a,b){for(void 0===b&&N("ptr should not be undefined");a.jd;)b=a.Ed(b),a=a.jd;return jb[b]}
function lb(a,b){b.hd&&b.gd||Va("makeClassHandle requires ptr and ptrType");!!b.od!==!!b.md&&Va("Both smartPtrType and smartPtr must be specified");b.count={value:1};return mb(Object.create(a,{ed:{value:b}}))}function mb(a){if("undefined"===typeof FinalizationRegistry)return mb=b=>b,a;ab=new FinalizationRegistry(b=>{db(b.ed)});mb=b=>{var c=b.ed;c.md&&ab.register(b,{ed:c},b);return b};bb=b=>{ab.unregister(b)};return mb(a)}function nb(){}
function ob(a){if(void 0===a)return"_unknown";a=a.replace(/[^a-zA-Z0-9_]/g,"$");var b=a.charCodeAt(0);return 48<=b&&57>=b?`_${a}`:a}function pb(a,b){a=ob(a);return{[a]:function(){return b.apply(this,arguments)}}[a]}
function qb(a,b,c){if(void 0===a[b].kd){var d=a[b];a[b]=function(){a[b].kd.hasOwnProperty(arguments.length)||N(`Function '${c}' called with an invalid number of arguments (${arguments.length}) - expects one of (${a[b].kd})!`);return a[b].kd[arguments.length].apply(this,arguments)};a[b].kd=[];a[b].kd[d.Hd]=d}}
function rb(a,b,c){k.hasOwnProperty(a)?((void 0===c||void 0!==k[a].kd&&void 0!==k[a].kd[c])&&N(`Cannot register public name '${a}' twice`),qb(k,a,a),k.hasOwnProperty(c)&&N(`Cannot register multiple overloads of a function with the same number of arguments (${c})!`),k[a].kd[c]=b):(k[a]=b,void 0!==c&&(k[a].We=c))}function sb(a,b,c,d,e,f,g,h){this.name=a;this.constructor=b;this.td=c;this.sd=d;this.jd=e;this.Ae=f;this.Ed=g;this.te=h;this.Je=[]}
function tb(a,b,c){for(;b!==c;)b.Ed||N(`Expected null or instance of ${c.name}, got an instance of ${b.name}`),a=b.Ed(a),b=b.jd;return a}function ub(a,b){if(null===b)return this.Sd&&N(`null is not a valid ${this.name}`),0;b.ed||N(`Cannot pass "${vb(b)}" as a ${this.name}`);b.ed.gd||N(`Cannot pass deleted object as a pointer of type ${this.name}`);return tb(b.ed.gd,b.ed.hd.fd,this.fd)}
function wb(a,b){if(null===b){this.Sd&&N(`null is not a valid ${this.name}`);if(this.Jd){var c=this.Td();null!==a&&a.push(this.sd,c);return c}return 0}b.ed||N(`Cannot pass "${vb(b)}" as a ${this.name}`);b.ed.gd||N(`Cannot pass deleted object as a pointer of type ${this.name}`);!this.Id&&b.ed.hd.Id&&N(`Cannot convert argument of type ${b.ed.od?b.ed.od.name:b.ed.hd.name} to parameter type ${this.name}`);c=tb(b.ed.gd,b.ed.hd.fd,this.fd);if(this.Jd)switch(void 0===b.ed.md&&N("Passing raw pointer to smart pointer is illegal"),
this.Oe){case 0:b.ed.od===this?c=b.ed.md:N(`Cannot convert argument of type ${b.ed.od?b.ed.od.name:b.ed.hd.name} to parameter type ${this.name}`);break;case 1:c=b.ed.md;break;case 2:if(b.ed.od===this)c=b.ed.md;else{var d=b.clone();c=this.Ke(c,xb(function(){d["delete"]()}));null!==a&&a.push(this.sd,c)}break;default:N("Unsupporting sharing policy")}return c}
function yb(a,b){if(null===b)return this.Sd&&N(`null is not a valid ${this.name}`),0;b.ed||N(`Cannot pass "${vb(b)}" as a ${this.name}`);b.ed.gd||N(`Cannot pass deleted object as a pointer of type ${this.name}`);b.ed.hd.Id&&N(`Cannot convert argument of type ${b.ed.hd.name} to parameter type ${this.name}`);return tb(b.ed.gd,b.ed.hd.fd,this.fd)}
function O(a,b,c,d){this.name=a;this.fd=b;this.Sd=c;this.Id=d;this.Jd=!1;this.sd=this.Ke=this.Td=this.ge=this.Oe=this.Ie=void 0;void 0!==b.jd?this.toWireType=wb:(this.toWireType=d?ub:yb,this.nd=null)}function zb(a,b,c){k.hasOwnProperty(a)||Va("Replacing nonexistant public symbol");void 0!==k[a].kd&&void 0!==c?k[a].kd[c]=b:(k[a]=b,k[a].Hd=c)}
var Ab=(a,b)=>{var c=[];return function(){c.length=0;Object.assign(c,arguments);if(a.includes("j")){var d=k["dynCall_"+a];d=c&&c.length?d.apply(null,[b].concat(c)):d.call(null,b)}else d=I.get(b).apply(null,c);return d}};function P(a,b){a=M(a);var c=a.includes("j")?Ab(a,b):I.get(b);"function"!=typeof c&&N(`unknown function pointer with signature ${a}: ${b}`);return c}var Bb=void 0;function Cb(a){a=Db(a);var b=M(a);Eb(a);return b}
function Fb(a,b){function c(f){e[f]||Sa[f]||(Ta[f]?Ta[f].forEach(c):(d.push(f),e[f]=!0))}var d=[],e={};b.forEach(c);throw new Bb(`${a}: `+d.map(Cb).join([", "]));}function Gb(a,b,c){a instanceof Object||N(`${c} with invalid "this": ${a}`);a instanceof b.fd.constructor||N(`${c} incompatible with "this" of type ${a.constructor.name}`);a.ed.gd||N(`cannot call emscripten binding method ${c} on deleted object`);return tb(a.ed.gd,a.ed.hd.fd,b.fd)}
function Hb(a,b){for(var c=[],d=0;d<a;d++)c.push(D[b+4*d>>2]);return c}
function Ib(a,b,c,d,e){var f=b.length;2>f&&N("argTypes array size mismatch! Must at least get return value and 'this' types!");var g=null!==b[1]&&null!==c,h=!1;for(c=1;c<b.length;++c)if(null!==b[c]&&void 0===b[c].nd){h=!0;break}var m="void"!==b[0].name,p=f-2,r=Array(p),v=[],z=[];return function(){arguments.length!==p&&N(`function ${a} called with ${arguments.length} arguments, expected ${p} args!`);z.length=0;v.length=g?2:1;v[0]=e;if(g){var l=b[1].toWireType(z,this);v[1]=l}for(var q=0;q<p;++q)r[q]=
b[q+2].toWireType(z,arguments[q]),v.push(r[q]);q=d.apply(null,v);if(h)Pa(z);else for(var u=g?1:2;u<b.length;u++){var x=1===u?l:r[u-2];null!==b[u].nd&&b[u].nd(x)}l=m?b[0].fromWireType(q):void 0;return l}}function Jb(){this.rd=[void 0];this.de=[]}var Q=new Jb;function Kb(a){a>=Q.be&&0===--Q.get(a).he&&Q.ze(a)}
var Lb=a=>{a||N("Cannot use deleted val. handle = "+a);return Q.get(a).value},xb=a=>{switch(a){case void 0:return 1;case null:return 2;case !0:return 3;case !1:return 4;default:return Q.we({he:1,value:a})}};function Mb(a,b,c){switch(b){case 0:return function(d){return this.fromWireType((c?ua:A)[d])};case 1:return function(d){return this.fromWireType((c?va:wa)[d>>1])};case 2:return function(d){return this.fromWireType((c?C:D)[d>>2])};default:throw new TypeError("Unknown integer type: "+a);}}
function Nb(a,b){var c=Sa[a];void 0===c&&N(b+" has unknown type "+Cb(a));return c}function vb(a){if(null===a)return"null";var b=typeof a;return"object"===b||"array"===b||"function"===b?a.toString():""+a}function Ob(a,b){switch(b){case 2:return function(c){return this.fromWireType(H[c>>2])};case 3:return function(c){return this.fromWireType(xa[c>>3])};default:throw new TypeError("Unknown float type: "+a);}}
function Pb(a,b,c){switch(b){case 0:return c?function(d){return ua[d]}:function(d){return A[d]};case 1:return c?function(d){return va[d>>1]}:function(d){return wa[d>>1]};case 2:return c?function(d){return C[d>>2]}:function(d){return D[d>>2]};default:throw new TypeError("Unknown integer type: "+a);}}
var Qb=(a,b,c,d)=>{if(!(0<d))return 0;var e=c;d=c+d-1;for(var f=0;f<a.length;++f){var g=a.charCodeAt(f);if(55296<=g&&57343>=g){var h=a.charCodeAt(++f);g=65536+((g&1023)<<10)|h&1023}if(127>=g){if(c>=d)break;b[c++]=g}else{if(2047>=g){if(c+1>=d)break;b[c++]=192|g>>6}else{if(65535>=g){if(c+2>=d)break;b[c++]=224|g>>12}else{if(c+3>=d)break;b[c++]=240|g>>18;b[c++]=128|g>>12&63}b[c++]=128|g>>6&63}b[c++]=128|g&63}}b[c]=0;return c-e},Rb=a=>{for(var b=0,c=0;c<a.length;++c){var d=a.charCodeAt(c);127>=d?b++:2047>=
d?b+=2:55296<=d&&57343>=d?(b+=4,++c):b+=3}return b},Sb="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,Tb=(a,b,c)=>{var d=b+c;for(c=b;a[c]&&!(c>=d);)++c;if(16<c-b&&a.buffer&&Sb)return Sb.decode(a.subarray(b,c));for(d="";b<c;){var e=a[b++];if(e&128){var f=a[b++]&63;if(192==(e&224))d+=String.fromCharCode((e&31)<<6|f);else{var g=a[b++]&63;e=224==(e&240)?(e&15)<<12|f<<6|g:(e&7)<<18|f<<12|g<<6|a[b++]&63;65536>e?d+=String.fromCharCode(e):(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|
e&1023))}}else d+=String.fromCharCode(e)}return d},Ub="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0,Vb=(a,b)=>{var c=a>>1;for(var d=c+b/2;!(c>=d)&&wa[c];)++c;c<<=1;if(32<c-a&&Ub)return Ub.decode(A.subarray(a,c));c="";for(d=0;!(d>=b/2);++d){var e=va[a+2*d>>1];if(0==e)break;c+=String.fromCharCode(e)}return c},Wb=(a,b,c)=>{void 0===c&&(c=2147483647);if(2>c)return 0;c-=2;var d=b;c=c<2*a.length?c/2:a.length;for(var e=0;e<c;++e)va[b>>1]=a.charCodeAt(e),b+=2;va[b>>1]=0;return b-d},Xb=
a=>2*a.length,Yb=(a,b)=>{for(var c=0,d="";!(c>=b/4);){var e=C[a+4*c>>2];if(0==e)break;++c;65536<=e?(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023)):d+=String.fromCharCode(e)}return d},Zb=(a,b,c)=>{void 0===c&&(c=2147483647);if(4>c)return 0;var d=b;c=d+c-4;for(var e=0;e<a.length;++e){var f=a.charCodeAt(e);if(55296<=f&&57343>=f){var g=a.charCodeAt(++e);f=65536+((f&1023)<<10)|g&1023}C[b>>2]=f;b+=4;if(b+4>c)break}C[b>>2]=0;return b-d},$b=a=>{for(var b=0,c=0;c<a.length;++c){var d=a.charCodeAt(c);
55296<=d&&57343>=d&&++c;b+=4}return b},ac={};function bc(a){var b=ac[a];return void 0===b?M(a):b}var cc=[];function dc(a){var b=cc.length;cc.push(a);return b}function ec(a,b){for(var c=Array(a),d=0;d<a;++d)c[d]=Nb(D[b+4*d>>2],"parameter "+d);return c}var fc=[];
function gc(a){var b=a.getExtension("ANGLE_instanced_arrays");b&&(a.vertexAttribDivisor=function(c,d){b.vertexAttribDivisorANGLE(c,d)},a.drawArraysInstanced=function(c,d,e,f){b.drawArraysInstancedANGLE(c,d,e,f)},a.drawElementsInstanced=function(c,d,e,f,g){b.drawElementsInstancedANGLE(c,d,e,f,g)})}
function hc(a){var b=a.getExtension("OES_vertex_array_object");b&&(a.createVertexArray=function(){return b.createVertexArrayOES()},a.deleteVertexArray=function(c){b.deleteVertexArrayOES(c)},a.bindVertexArray=function(c){b.bindVertexArrayOES(c)},a.isVertexArray=function(c){return b.isVertexArrayOES(c)})}function ic(a){var b=a.getExtension("WEBGL_draw_buffers");b&&(a.drawBuffers=function(c,d){b.drawBuffersWEBGL(c,d)})}
var jc=1,kc=[],R=[],lc=[],mc=[],nc=[],S=[],oc=[],fa=[],pc=[],qc=[],rc={},sc={},tc=4;function T(a){uc||(uc=a)}function ea(a){for(var b=jc++,c=a.length;c<b;c++)a[c]=null;return b}
function ha(a){a||(a=n);if(!a.Ge){a.Ge=!0;var b=a.Pd;gc(b);hc(b);ic(b);b.$d=b.getExtension("WEBGL_draw_instanced_base_vertex_base_instance");b.ee=b.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance");2<=a.version&&(b.ae=b.getExtension("EXT_disjoint_timer_query_webgl2"));if(2>a.version||!b.ae)b.ae=b.getExtension("EXT_disjoint_timer_query");b.Ve=b.getExtension("WEBGL_multi_draw");(b.getSupportedExtensions()||[]).forEach(function(c){c.includes("lose_context")||c.includes("debug")||b.getExtension(c)})}}
var uc,n;function vc(a,b){t.bindFramebuffer(a,lc[b])}function wc(a){t.bindVertexArray(oc[a])}function xc(a,b){for(var c=0;c<a;c++){var d=C[b+4*c>>2];t.deleteVertexArray(oc[d]);oc[d]=null}}var yc=[];function zc(a,b,c,d){t.drawElements(a,b,c,d)}function Ac(a,b,c,d){for(var e=0;e<a;e++){var f=t[c](),g=f&&ea(d);f?(f.name=g,d[g]=f):T(1282);C[b+4*e>>2]=g}}function Bc(a,b){Ac(a,b,"createVertexArray",oc)}
function Cc(a,b){if(b){var c=void 0;switch(a){case 36346:c=1;break;case 36344:return;case 34814:case 36345:c=0;break;case 34466:var d=t.getParameter(34467);c=d?d.length:0;break;case 33309:if(2>n.version){T(1282);return}c=2*(t.getSupportedExtensions()||[]).length;break;case 33307:case 33308:if(2>n.version){T(1280);return}c=33307==a?3:0}if(void 0===c)switch(d=t.getParameter(a),typeof d){case "number":c=d;break;case "boolean":c=d?1:0;break;case "string":T(1280);return;case "object":if(null===d)switch(a){case 34964:case 35725:case 34965:case 36006:case 36007:case 32873:case 34229:case 36662:case 36663:case 35053:case 35055:case 36010:case 35097:case 35869:case 32874:case 36389:case 35983:case 35368:case 34068:c=
0;break;default:T(1280);return}else{if(d instanceof Float32Array||d instanceof Uint32Array||d instanceof Int32Array||d instanceof Array){for(a=0;a<d.length;++a)C[b+4*a>>2]=d[a];return}try{c=d.name|0}catch(e){T(1280);pa("GL_INVALID_ENUM in glGet0v: Unknown object returned from WebGL getParameter("+a+")! (error: "+e+")");return}}break;default:T(1280);pa("GL_INVALID_ENUM in glGet0v: Native code calling glGet0v("+a+") and it returns "+d+" of type "+typeof d+"!");return}C[b>>2]=c}else T(1281)}
function Dc(a,b){Cc(a,b)}var Fc=a=>{var b=Rb(a)+1,c=Ec(b);c&&Qb(a,A,c,b);return c};function Gc(a){return"]"==a.slice(-1)&&a.lastIndexOf("[")}function Hc(a){a-=5120;return 0==a?ua:1==a?A:2==a?va:4==a?C:6==a?H:5==a||28922==a||28520==a||30779==a||30782==a?D:wa}function Ic(a,b,c,d,e){a=Hc(a);var f=31-Math.clz32(a.BYTES_PER_ELEMENT),g=tc;return a.subarray(e>>f,e+d*(c*({5:3,6:4,8:2,29502:3,29504:4,26917:2,26918:2,29846:3,29847:4}[b-6402]||1)*(1<<f)+g-1&-g)>>f)}
function U(a){var b=t.re;if(b){var c=b.Dd[a];"number"==typeof c&&(b.Dd[a]=c=t.getUniformLocation(b,b.ie[a]+(0<c?"["+c+"]":"")));return c}T(1282)}
var Jc=[],Kc=[],Lc={},Nc=()=>{if(!Mc){var a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ja||"./this.program"},b;for(b in Lc)void 0===Lc[b]?delete a[b]:a[b]=Lc[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Mc=c}return Mc},Mc,Oc=[null,[],[]],Pc=a=>0===a%4&&(0!==a%100||0===a%400),Qc=[31,29,31,30,31,30,31,31,30,31,30,31],Rc=[31,28,31,30,31,30,31,31,30,31,30,31];
function Sc(a){var b=Array(Rb(a)+1);Qb(a,b,0,b.length);return b}
var Tc=(a,b,c,d)=>{function e(l,q,u){for(l="number"==typeof l?l.toString():l||"";l.length<q;)l=u[0]+l;return l}function f(l,q){return e(l,q,"0")}function g(l,q){function u(E){return 0>E?-1:0<E?1:0}var x;0===(x=u(l.getFullYear()-q.getFullYear()))&&0===(x=u(l.getMonth()-q.getMonth()))&&(x=u(l.getDate()-q.getDate()));return x}function h(l){switch(l.getDay()){case 0:return new Date(l.getFullYear()-1,11,29);case 1:return l;case 2:return new Date(l.getFullYear(),0,3);case 3:return new Date(l.getFullYear(),
0,2);case 4:return new Date(l.getFullYear(),0,1);case 5:return new Date(l.getFullYear()-1,11,31);case 6:return new Date(l.getFullYear()-1,11,30)}}function m(l){var q=l.vd;for(l=new Date((new Date(l.wd+1900,0,1)).getTime());0<q;){var u=l.getMonth(),x=(Pc(l.getFullYear())?Qc:Rc)[u];if(q>x-l.getDate())q-=x-l.getDate()+1,l.setDate(1),11>u?l.setMonth(u+1):(l.setMonth(0),l.setFullYear(l.getFullYear()+1));else{l.setDate(l.getDate()+q);break}}u=new Date(l.getFullYear()+1,0,4);q=h(new Date(l.getFullYear(),
0,4));u=h(u);return 0>=g(q,l)?0>=g(u,l)?l.getFullYear()+1:l.getFullYear():l.getFullYear()-1}var p=C[d+40>>2];d={Re:C[d>>2],Qe:C[d+4>>2],Nd:C[d+8>>2],Ud:C[d+12>>2],Od:C[d+16>>2],wd:C[d+20>>2],pd:C[d+24>>2],vd:C[d+28>>2],Xe:C[d+32>>2],Pe:C[d+36>>2],Se:p?p?Tb(A,p):"":""};c=c?Tb(A,c):"";p={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y",
"%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var r in p)c=c.replace(new RegExp(r,"g"),p[r]);var v="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),z="January February March April May June July August September October November December".split(" ");p={"%a":l=>v[l.pd].substring(0,3),"%A":l=>v[l.pd],"%b":l=>z[l.Od].substring(0,3),"%B":l=>z[l.Od],"%C":l=>f((l.wd+1900)/
100|0,2),"%d":l=>f(l.Ud,2),"%e":l=>e(l.Ud,2," "),"%g":l=>m(l).toString().substring(2),"%G":l=>m(l),"%H":l=>f(l.Nd,2),"%I":l=>{l=l.Nd;0==l?l=12:12<l&&(l-=12);return f(l,2)},"%j":l=>{for(var q=0,u=0;u<=l.Od-1;q+=(Pc(l.wd+1900)?Qc:Rc)[u++]);return f(l.Ud+q,3)},"%m":l=>f(l.Od+1,2),"%M":l=>f(l.Qe,2),"%n":()=>"\n","%p":l=>0<=l.Nd&&12>l.Nd?"AM":"PM","%S":l=>f(l.Re,2),"%t":()=>"\t","%u":l=>l.pd||7,"%U":l=>f(Math.floor((l.vd+7-l.pd)/7),2),"%V":l=>{var q=Math.floor((l.vd+7-(l.pd+6)%7)/7);2>=(l.pd+371-l.vd-
2)%7&&q++;if(q)53==q&&(u=(l.pd+371-l.vd)%7,4==u||3==u&&Pc(l.wd)||(q=1));else{q=52;var u=(l.pd+7-l.vd-1)%7;(4==u||5==u&&Pc(l.wd%400-1))&&q++}return f(q,2)},"%w":l=>l.pd,"%W":l=>f(Math.floor((l.vd+7-(l.pd+6)%7)/7),2),"%y":l=>(l.wd+1900).toString().substring(2),"%Y":l=>l.wd+1900,"%z":l=>{l=l.Pe;var q=0<=l;l=Math.abs(l)/60;return(q?"+":"-")+String("0000"+(l/60*100+l%60)).slice(-4)},"%Z":l=>l.Se,"%%":()=>"%"};c=c.replace(/%%/g,"\x00\x00");for(r in p)c.includes(r)&&(c=c.replace(new RegExp(r,"g"),p[r](d)));
c=c.replace(/\0\0/g,"%");r=Sc(c);if(r.length>b)return 0;ua.set(r,a);return r.length-1};Ua=k.InternalError=class extends Error{constructor(a){super(a);this.name="InternalError"}};for(var Uc=Array(256),Vc=0;256>Vc;++Vc)Uc[Vc]=String.fromCharCode(Vc);Xa=Uc;Ya=k.BindingError=class extends Error{constructor(a){super(a);this.name="BindingError"}};
nb.prototype.isAliasOf=function(a){if(!(this instanceof nb&&a instanceof nb))return!1;var b=this.ed.hd.fd,c=this.ed.gd,d=a.ed.hd.fd;for(a=a.ed.gd;b.jd;)c=b.Ed(c),b=b.jd;for(;d.jd;)a=d.Ed(a),d=d.jd;return b===d&&c===a};
nb.prototype.clone=function(){this.ed.gd||$a(this);if(this.ed.Cd)return this.ed.count.value+=1,this;var a=mb,b=Object,c=b.create,d=Object.getPrototypeOf(this),e=this.ed;a=a(c.call(b,d,{ed:{value:{count:e.count,Ad:e.Ad,Cd:e.Cd,gd:e.gd,hd:e.hd,md:e.md,od:e.od}}}));a.ed.count.value+=1;a.ed.Ad=!1;return a};nb.prototype["delete"]=function(){this.ed.gd||$a(this);this.ed.Ad&&!this.ed.Cd&&N("Object already scheduled for deletion");bb(this);db(this.ed);this.ed.Cd||(this.ed.md=void 0,this.ed.gd=void 0)};
nb.prototype.isDeleted=function(){return!this.ed.gd};nb.prototype.deleteLater=function(){this.ed.gd||$a(this);this.ed.Ad&&!this.ed.Cd&&N("Object already scheduled for deletion");gb.push(this);1===gb.length&&ib&&ib(hb);this.ed.Ad=!0;return this};k.getInheritedInstanceCount=function(){return Object.keys(jb).length};k.getLiveInheritedInstances=function(){var a=[],b;for(b in jb)jb.hasOwnProperty(b)&&a.push(jb[b]);return a};k.flushPendingDeletes=hb;k.setDelayFunction=function(a){ib=a;gb.length&&ib&&ib(hb)};
O.prototype.Be=function(a){this.ge&&(a=this.ge(a));return a};O.prototype.Zd=function(a){this.sd&&this.sd(a)};O.prototype.argPackAdvance=8;O.prototype.readValueFromPointer=Qa;O.prototype.deleteObject=function(a){if(null!==a)a["delete"]()};
O.prototype.fromWireType=function(a){function b(){return this.Jd?lb(this.fd.td,{hd:this.Ie,gd:c,od:this,md:a}):lb(this.fd.td,{hd:this,gd:a})}var c=this.Be(a);if(!c)return this.Zd(a),null;var d=kb(this.fd,c);if(void 0!==d){if(0===d.ed.count.value)return d.ed.gd=c,d.ed.md=a,d.clone();d=d.clone();this.Zd(a);return d}d=this.fd.Ae(c);d=fb[d];if(!d)return b.call(this);d=this.Id?d.pe:d.pointerType;var e=eb(c,this.fd,d.fd);return null===e?b.call(this):this.Jd?lb(d.fd.td,{hd:d,gd:e,od:this,md:a}):lb(d.fd.td,
{hd:d,gd:e})};Bb=k.UnboundTypeError=function(a,b){var c=pb(b,function(d){this.name=b;this.message=d;d=Error(d).stack;void 0!==d&&(this.stack=this.toString()+"\n"+d.replace(/^Error(:[^\n]*)?\n/,""))});c.prototype=Object.create(a.prototype);c.prototype.constructor=c;c.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`};return c}(Error,"UnboundTypeError");
Object.assign(Jb.prototype,{get(a){return this.rd[a]},has(a){return void 0!==this.rd[a]},we(a){var b=this.de.pop()||this.rd.length;this.rd[b]=a;return b},ze(a){this.rd[a]=void 0;this.de.push(a)}});Q.rd.push({value:void 0},{value:null},{value:!0},{value:!1});Q.be=Q.rd.length;k.count_emval_handles=function(){for(var a=0,b=Q.be;b<Q.rd.length;++b)void 0!==Q.rd[b]&&++a;return a};for(var t,V=0;32>V;++V)yc.push(Array(V));var Wc=new Float32Array(288);for(V=0;288>V;++V)Jc[V]=Wc.subarray(0,V+1);var Xc=new Int32Array(288);
for(V=0;288>V;++V)Kc[V]=Xc.subarray(0,V+1);
var ld={sb:function(a){var b=Oa[a];delete Oa[a];var c=b.Td,d=b.sd,e=b.ce,f=e.map(g=>g.Ee).concat(e.map(g=>g.Me));K([a],f,g=>{var h={};e.forEach((m,p)=>{var r=g[p],v=m.Ce,z=m.De,l=g[p+e.length],q=m.Le,u=m.Ne;h[m.xe]={read:x=>r.fromWireType(v(z,x)),write:(x,E)=>{var B=[];q(u,x,l.toWireType(B,E));Pa(B)}}});return[{name:b.name,fromWireType:function(m){var p={},r;for(r in h)p[r]=h[r].read(m);d(m);return p},toWireType:function(m,p){for(var r in h)if(!(r in p))throw new TypeError(`Missing field: "${r}"`);var v=
c();for(r in h)h[r].write(v,p[r]);null!==m&&m.push(d,v);return v},argPackAdvance:8,readValueFromPointer:Qa,nd:d}]})},db:function(){},ub:function(a,b,c,d,e){var f=Wa(c);b=M(b);L(a,{name:b,fromWireType:function(g){return!!g},toWireType:function(g,h){return h?d:e},argPackAdvance:8,readValueFromPointer:function(g){if(1===c)var h=ua;else if(2===c)h=va;else if(4===c)h=C;else throw new TypeError("Unknown boolean type size: "+b);return this.fromWireType(h[g>>f])},nd:null})},g:function(a,b,c,d,e,f,g,h,m,p,
r,v,z){r=M(r);f=P(e,f);h&&(h=P(g,h));p&&(p=P(m,p));z=P(v,z);var l=ob(r);rb(l,function(){Fb(`Cannot construct ${r} due to unbound types`,[d])});K([a,b,c],d?[d]:[],function(q){q=q[0];if(d){var u=q.fd;var x=u.td}else x=nb.prototype;q=pb(l,function(){if(Object.getPrototypeOf(this)!==E)throw new Ya("Use 'new' to construct "+r);if(void 0===B.ud)throw new Ya(r+" has no accessible constructor");var J=B.ud[arguments.length];if(void 0===J)throw new Ya(`Tried to invoke ctor of ${r} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(B.ud).toString()}) parameters instead!`);
return J.apply(this,arguments)});var E=Object.create(x,{constructor:{value:q}});q.prototype=E;var B=new sb(r,q,E,z,u,f,h,p);B.jd&&(void 0===B.jd.Wd&&(B.jd.Wd=[]),B.jd.Wd.push(B));u=new O(r,B,!0,!1);x=new O(r+"*",B,!1,!1);var F=new O(r+" const*",B,!1,!0);fb[a]={pointerType:x,pe:F};zb(l,q);return[u,x,F]})},y:function(a,b,c,d,e,f,g,h){b=M(b);f=P(e,f);K([],[a],function(m){m=m[0];var p=`${m.name}.${b}`,r={get(){Fb(`Cannot access ${p} due to unbound types`,[c])},enumerable:!0,configurable:!0};r.set=h?()=>
{Fb(`Cannot access ${p} due to unbound types`,[c])}:()=>{N(`${p} is a read-only property`)};Object.defineProperty(m.fd.constructor,b,r);K([],[c],function(v){v=v[0];var z={get(){return v.fromWireType(f(d))},enumerable:!0};h&&(h=P(g,h),z.set=l=>{var q=[];h(d,v.toWireType(q,l));Pa(q)});Object.defineProperty(m.fd.constructor,b,z);return[]});return[]})},r:function(a,b,c,d,e,f){var g=Hb(b,c);e=P(d,e);K([],[a],function(h){h=h[0];var m=`constructor ${h.name}`;void 0===h.fd.ud&&(h.fd.ud=[]);if(void 0!==h.fd.ud[b-
1])throw new Ya(`Cannot register multiple constructors with identical number of parameters (${b-1}) for class '${h.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);h.fd.ud[b-1]=()=>{Fb(`Cannot construct ${h.name} due to unbound types`,g)};K([],g,function(p){p.splice(1,0,null);h.fd.ud[b-1]=Ib(m,p,null,e,f);return[]});return[]})},c:function(a,b,c,d,e,f,g,h){var m=Hb(c,d);b=M(b);f=P(e,f);K([],[a],function(p){function r(){Fb(`Cannot call ${v} due to unbound types`,
m)}p=p[0];var v=`${p.name}.${b}`;b.startsWith("@@")&&(b=Symbol[b.substring(2)]);h&&p.fd.Je.push(b);var z=p.fd.td,l=z[b];void 0===l||void 0===l.kd&&l.className!==p.name&&l.Hd===c-2?(r.Hd=c-2,r.className=p.name,z[b]=r):(qb(z,b,v),z[b].kd[c-2]=r);K([],m,function(q){q=Ib(v,q,p,f,g);void 0===z[b].kd?(q.Hd=c-2,z[b]=q):z[b].kd[c-2]=q;return[]});return[]})},f:function(a,b,c,d,e,f,g,h,m,p){b=M(b);e=P(d,e);K([],[a],function(r){r=r[0];var v=`${r.name}.${b}`,z={get(){Fb(`Cannot access ${v} due to unbound types`,
[c,g])},enumerable:!0,configurable:!0};z.set=m?()=>{Fb(`Cannot access ${v} due to unbound types`,[c,g])}:()=>{N(v+" is a read-only property")};Object.defineProperty(r.fd.td,b,z);K([],m?[c,g]:[c],function(l){var q=l[0],u={get(){var E=Gb(this,r,v+" getter");return q.fromWireType(e(f,E))},enumerable:!0};if(m){m=P(h,m);var x=l[1];u.set=function(E){var B=Gb(this,r,v+" setter"),F=[];m(p,B,x.toWireType(F,E));Pa(F)}}Object.defineProperty(r.fd.td,b,u);return[]});return[]})},tb:function(a,b){b=M(b);L(a,{name:b,
fromWireType:function(c){var d=Lb(c);Kb(c);return d},toWireType:function(c,d){return xb(d)},argPackAdvance:8,readValueFromPointer:Qa,nd:null})},F:function(a,b,c,d){function e(){}c=Wa(c);b=M(b);e.values={};L(a,{name:b,constructor:e,fromWireType:function(f){return this.constructor.values[f]},toWireType:function(f,g){return g.value},argPackAdvance:8,readValueFromPointer:Mb(b,c,d),nd:null});rb(b,e)},k:function(a,b,c){var d=Nb(a,"enum");b=M(b);a=d.constructor;d=Object.create(d.constructor.prototype,{value:{value:c},
constructor:{value:pb(`${d.name}_${b}`,function(){})}});a.values[c]=d;a[b]=d},D:function(a,b,c){c=Wa(c);b=M(b);L(a,{name:b,fromWireType:function(d){return d},toWireType:function(d,e){return e},argPackAdvance:8,readValueFromPointer:Ob(b,c),nd:null})},s:function(a,b,c,d,e,f){var g=Hb(b,c);a=M(a);e=P(d,e);rb(a,function(){Fb(`Cannot call ${a} due to unbound types`,g)},b-1);K([],g,function(h){zb(a,Ib(a,[h[0],null].concat(h.slice(1)),null,e,f),b-1);return[]})},n:function(a,b,c,d,e){b=M(b);-1===e&&(e=4294967295);
e=Wa(c);var f=h=>h;if(0===d){var g=32-8*c;f=h=>h<<g>>>g}c=b.includes("unsigned")?function(h,m){return m>>>0}:function(h,m){return m};L(a,{name:b,fromWireType:f,toWireType:c,argPackAdvance:8,readValueFromPointer:Pb(b,e,0!==d),nd:null})},j:function(a,b,c){function d(f){f>>=2;var g=D;return new e(g.buffer,g[f+1],g[f])}var e=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][b];c=M(c);L(a,{name:c,fromWireType:d,argPackAdvance:8,readValueFromPointer:d},{Fe:!0})},
E:function(a,b){b=M(b);var c="std::string"===b;L(a,{name:b,fromWireType:function(d){var e=D[d>>2],f=d+4;if(c)for(var g=f,h=0;h<=e;++h){var m=f+h;if(h==e||0==A[m]){g=g?Tb(A,g,m-g):"";if(void 0===p)var p=g;else p+=String.fromCharCode(0),p+=g;g=m+1}}else{p=Array(e);for(h=0;h<e;++h)p[h]=String.fromCharCode(A[f+h]);p=p.join("")}Eb(d);return p},toWireType:function(d,e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var f="string"==typeof e;f||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof
Int8Array||N("Cannot pass non-string to std::string");var g=c&&f?Rb(e):e.length;var h=Ec(4+g+1),m=h+4;D[h>>2]=g;if(c&&f)Qb(e,A,m,g+1);else if(f)for(f=0;f<g;++f){var p=e.charCodeAt(f);255<p&&(Eb(m),N("String has UTF-16 code units that do not fit in 8 bits"));A[m+f]=p}else for(f=0;f<g;++f)A[m+f]=e[f];null!==d&&d.push(Eb,h);return h},argPackAdvance:8,readValueFromPointer:Qa,nd:function(d){Eb(d)}})},x:function(a,b,c){c=M(c);if(2===b){var d=Vb;var e=Wb;var f=Xb;var g=()=>wa;var h=1}else 4===b&&(d=Yb,e=
Zb,f=$b,g=()=>D,h=2);L(a,{name:c,fromWireType:function(m){for(var p=D[m>>2],r=g(),v,z=m+4,l=0;l<=p;++l){var q=m+4+l*b;if(l==p||0==r[q>>h])z=d(z,q-z),void 0===v?v=z:(v+=String.fromCharCode(0),v+=z),z=q+b}Eb(m);return v},toWireType:function(m,p){"string"!=typeof p&&N(`Cannot pass non-string to C++ string type ${c}`);var r=f(p),v=Ec(4+r+b);D[v>>2]=r>>h;e(p,v+4,r+b);null!==m&&m.push(Eb,v);return v},argPackAdvance:8,readValueFromPointer:Qa,nd:function(m){Eb(m)}})},Kb:function(a,b,c,d,e,f){Oa[a]={name:M(b),
Td:P(c,d),sd:P(e,f),ce:[]}},zb:function(a,b,c,d,e,f,g,h,m,p){Oa[a].ce.push({xe:M(b),Ee:c,Ce:P(d,e),De:f,Me:g,Le:P(h,m),Ne:p})},vb:function(a,b){b=M(b);L(a,{He:!0,name:b,argPackAdvance:0,fromWireType:function(){},toWireType:function(){}})},mb:()=>!0,ib:()=>{throw Infinity;},gb:function(a,b,c){a=Lb(a);b=Nb(b,"emval::as");var d=[],e=xb(d);D[c>>2]=e;return b.toWireType(d,a)},ab:function(a,b,c,d){a=cc[a];b=Lb(b);c=bc(c);a(b,c,null,d)},h:Kb,$a:function(a,b){var c=ec(a,b),d=c[0];b=d.name+"_$"+c.slice(1).map(function(g){return g.name}).join("_")+
"$";var e=fc[b];if(void 0!==e)return e;var f=Array(a-1);e=dc((g,h,m,p)=>{for(var r=0,v=0;v<a-1;++v)f[v]=c[v+1].readValueFromPointer(p+r),r+=c[v+1].argPackAdvance;g=g[h].apply(g,f);for(v=0;v<a-1;++v)c[v+1].se&&c[v+1].se(f[v]);if(!d.He)return d.toWireType(m,g)});return fc[b]=e},jb:function(a,b){a=Lb(a);b=Lb(b);return xb(a[b])},A:function(a){4<a&&(Q.get(a).he+=1)},q:function(a){return xb(bc(a))},z:function(){return xb({})},bb:function(a){var b=Lb(a);Pa(b);Kb(a)},o:function(a,b,c){a=Lb(a);b=Lb(b);c=Lb(c);
a[b]=c},v:function(a,b){a=Nb(a,"_emval_take_value");a=a.readValueFromPointer(b);return xb(a)},a:()=>{ra("")},nb:()=>performance.now(),Va:function(a){t.activeTexture(a)},Ua:function(a,b){t.attachShader(R[a],S[b])},Ta:function(a,b,c){t.bindAttribLocation(R[a],b,c?Tb(A,c):"")},Sa:function(a,b){35051==a?t.Rd=b:35052==a&&(t.zd=b);t.bindBuffer(a,kc[b])},Xb:vc,Wb:function(a,b){t.bindRenderbuffer(a,mc[b])},Eb:function(a,b){t.bindSampler(a,pc[b])},Ra:function(a,b){t.bindTexture(a,nc[b])},nc:wc,kc:wc,Qa:function(a,
b,c,d){t.blendColor(a,b,c,d)},Pa:function(a){t.blendEquation(a)},Oa:function(a,b){t.blendFunc(a,b)},Jb:function(a,b,c,d,e,f,g,h,m,p){t.blitFramebuffer(a,b,c,d,e,f,g,h,m,p)},Na:function(a,b,c,d){2<=n.version?c&&b?t.bufferData(a,A,d,c,b):t.bufferData(a,b,d):t.bufferData(a,c?A.subarray(c,c+b):b,d)},Ma:function(a,b,c,d){2<=n.version?c&&t.bufferSubData(a,b,A,d,c):t.bufferSubData(a,b,A.subarray(d,d+c))},Vb:function(a){return t.checkFramebufferStatus(a)},La:function(a){t.clear(a)},Ka:function(a,b,c,d){t.clearColor(a,
b,c,d)},Ja:function(a){t.clearStencil(a)},Ya:function(a,b,c,d){return t.clientWaitSync(qc[a],b,(c>>>0)+4294967296*d)},Ia:function(a,b,c,d){t.colorMask(!!a,!!b,!!c,!!d)},Ha:function(a){t.compileShader(S[a])},Ga:function(a,b,c,d,e,f,g,h){2<=n.version?t.zd||!g?t.compressedTexImage2D(a,b,c,d,e,f,g,h):t.compressedTexImage2D(a,b,c,d,e,f,A,h,g):t.compressedTexImage2D(a,b,c,d,e,f,h?A.subarray(h,h+g):null)},Fa:function(a,b,c,d,e,f,g,h,m){2<=n.version?t.zd||!h?t.compressedTexSubImage2D(a,b,c,d,e,f,g,h,m):t.compressedTexSubImage2D(a,
b,c,d,e,f,g,A,m,h):t.compressedTexSubImage2D(a,b,c,d,e,f,g,m?A.subarray(m,m+h):null)},Ea:function(a,b,c,d,e,f,g,h){t.copyTexSubImage2D(a,b,c,d,e,f,g,h)},Da:function(){var a=ea(R),b=t.createProgram();b.name=a;b.Md=b.Kd=b.Ld=0;b.Vd=1;R[a]=b;return a},Ca:function(a){var b=ea(S);S[b]=t.createShader(a);return b},Ba:function(a){t.cullFace(a)},Aa:function(a,b){for(var c=0;c<a;c++){var d=C[b+4*c>>2],e=kc[d];e&&(t.deleteBuffer(e),e.name=0,kc[d]=null,d==t.Rd&&(t.Rd=0),d==t.zd&&(t.zd=0))}},Ub:function(a,b){for(var c=
0;c<a;++c){var d=C[b+4*c>>2],e=lc[d];e&&(t.deleteFramebuffer(e),e.name=0,lc[d]=null)}},za:function(a){if(a){var b=R[a];b?(t.deleteProgram(b),b.name=0,R[a]=null):T(1281)}},Tb:function(a,b){for(var c=0;c<a;c++){var d=C[b+4*c>>2],e=mc[d];e&&(t.deleteRenderbuffer(e),e.name=0,mc[d]=null)}},Db:function(a,b){for(var c=0;c<a;c++){var d=C[b+4*c>>2],e=pc[d];e&&(t.deleteSampler(e),e.name=0,pc[d]=null)}},ya:function(a){if(a){var b=S[a];b?(t.deleteShader(b),S[a]=null):T(1281)}},Hb:function(a){if(a){var b=qc[a];
b?(t.deleteSync(b),b.name=0,qc[a]=null):T(1281)}},xa:function(a,b){for(var c=0;c<a;c++){var d=C[b+4*c>>2],e=nc[d];e&&(t.deleteTexture(e),e.name=0,nc[d]=null)}},mc:xc,jc:xc,wa:function(a){t.depthMask(!!a)},va:function(a){t.disable(a)},ua:function(a){t.disableVertexAttribArray(a)},ta:function(a,b,c){t.drawArrays(a,b,c)},hc:function(a,b,c,d){t.drawArraysInstanced(a,b,c,d)},fc:function(a,b,c,d,e){t.$d.drawArraysInstancedBaseInstanceWEBGL(a,b,c,d,e)},dc:function(a,b){for(var c=yc[a],d=0;d<a;d++)c[d]=C[b+
4*d>>2];t.drawBuffers(c)},sa:zc,gc:function(a,b,c,d,e){t.drawElementsInstanced(a,b,c,d,e)},ec:function(a,b,c,d,e,f,g){t.$d.drawElementsInstancedBaseVertexBaseInstanceWEBGL(a,b,c,d,e,f,g)},$b:function(a,b,c,d,e,f){zc(a,d,e,f)},ra:function(a){t.enable(a)},qa:function(a){t.enableVertexAttribArray(a)},Gb:function(a,b){return(a=t.fenceSync(a,b))?(b=ea(qc),a.name=b,qc[b]=a,b):0},pa:function(){t.finish()},oa:function(){t.flush()},Sb:function(a,b,c,d){t.framebufferRenderbuffer(a,b,c,mc[d])},Rb:function(a,
b,c,d,e){t.framebufferTexture2D(a,b,c,nc[d],e)},na:function(a){t.frontFace(a)},ma:function(a,b){Ac(a,b,"createBuffer",kc)},Qb:function(a,b){Ac(a,b,"createFramebuffer",lc)},Pb:function(a,b){Ac(a,b,"createRenderbuffer",mc)},Cb:function(a,b){Ac(a,b,"createSampler",pc)},la:function(a,b){Ac(a,b,"createTexture",nc)},lc:Bc,ic:Bc,Ob:function(a){t.generateMipmap(a)},ka:function(a,b,c){c?C[c>>2]=t.getBufferParameter(a,b):T(1281)},ja:function(){var a=t.getError()||uc;uc=0;return a},Nb:function(a,b,c,d){a=t.getFramebufferAttachmentParameter(a,
b,c);if(a instanceof WebGLRenderbuffer||a instanceof WebGLTexture)a=a.name|0;C[d>>2]=a},Wa:Dc,ia:function(a,b,c,d){a=t.getProgramInfoLog(R[a]);null===a&&(a="(unknown error)");b=0<b&&d?Qb(a,A,d,b):0;c&&(C[c>>2]=b)},ha:function(a,b,c){if(c)if(a>=jc)T(1281);else if(a=R[a],35716==b)a=t.getProgramInfoLog(a),null===a&&(a="(unknown error)"),C[c>>2]=a.length+1;else if(35719==b){if(!a.Md)for(b=0;b<t.getProgramParameter(a,35718);++b)a.Md=Math.max(a.Md,t.getActiveUniform(a,b).name.length+1);C[c>>2]=a.Md}else if(35722==
b){if(!a.Kd)for(b=0;b<t.getProgramParameter(a,35721);++b)a.Kd=Math.max(a.Kd,t.getActiveAttrib(a,b).name.length+1);C[c>>2]=a.Kd}else if(35381==b){if(!a.Ld)for(b=0;b<t.getProgramParameter(a,35382);++b)a.Ld=Math.max(a.Ld,t.getActiveUniformBlockName(a,b).length+1);C[c>>2]=a.Ld}else C[c>>2]=t.getProgramParameter(a,b);else T(1281)},Mb:function(a,b,c){c?C[c>>2]=t.getRenderbufferParameter(a,b):T(1281)},ga:function(a,b,c,d){a=t.getShaderInfoLog(S[a]);null===a&&(a="(unknown error)");b=0<b&&d?Qb(a,A,d,b):0;
c&&(C[c>>2]=b)},wb:function(a,b,c,d){a=t.getShaderPrecisionFormat(a,b);C[c>>2]=a.rangeMin;C[c+4>>2]=a.rangeMax;C[d>>2]=a.precision},fa:function(a,b,c){c?35716==b?(a=t.getShaderInfoLog(S[a]),null===a&&(a="(unknown error)"),C[c>>2]=a?a.length+1:0):35720==b?(a=t.getShaderSource(S[a]),C[c>>2]=a?a.length+1:0):C[c>>2]=t.getShaderParameter(S[a],b):T(1281)},w:function(a){var b=rc[a];if(!b){switch(a){case 7939:b=t.getSupportedExtensions()||[];b=b.concat(b.map(function(d){return"GL_"+d}));b=Fc(b.join(" "));
break;case 7936:case 7937:case 37445:case 37446:(b=t.getParameter(a))||T(1280);b=b&&Fc(b);break;case 7938:b=t.getParameter(7938);b=2<=n.version?"OpenGL ES 3.0 ("+b+")":"OpenGL ES 2.0 ("+b+")";b=Fc(b);break;case 35724:b=t.getParameter(35724);var c=b.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);null!==c&&(3==c[1].length&&(c[1]+="0"),b="OpenGL ES GLSL ES "+c[1]+" ("+b+")");b=Fc(b);break;default:T(1280)}rc[a]=b}return b},Xa:function(a,b){if(2>n.version)return T(1282),0;var c=sc[a];if(c)return 0>
b||b>=c.length?(T(1281),0):c[b];switch(a){case 7939:return c=t.getSupportedExtensions()||[],c=c.concat(c.map(function(d){return"GL_"+d})),c=c.map(function(d){return Fc(d)}),c=sc[a]=c,0>b||b>=c.length?(T(1281),0):c[b];default:return T(1280),0}},ea:function(a,b){b=b?Tb(A,b):"";if(a=R[a]){var c=a,d=c.Dd,e=c.je,f;if(!d)for(c.Dd=d={},c.ie={},f=0;f<t.getProgramParameter(c,35718);++f){var g=t.getActiveUniform(c,f);var h=g.name;g=g.size;var m=Gc(h);m=0<m?h.slice(0,m):h;var p=c.Vd;c.Vd+=g;e[m]=[g,p];for(h=
0;h<g;++h)d[p]=h,c.ie[p++]=m}c=a.Dd;d=0;e=b;f=Gc(b);0<f&&(d=parseInt(b.slice(f+1))>>>0,e=b.slice(0,f));if((e=a.je[e])&&d<e[0]&&(d+=e[1],c[d]=c[d]||t.getUniformLocation(a,b)))return d}else T(1281);return-1},yb:function(a,b,c){for(var d=yc[b],e=0;e<b;e++)d[e]=C[c+4*e>>2];t.invalidateFramebuffer(a,d)},xb:function(a,b,c,d,e,f,g){for(var h=yc[b],m=0;m<b;m++)h[m]=C[c+4*m>>2];t.invalidateSubFramebuffer(a,h,d,e,f,g)},Fb:function(a){return t.isSync(qc[a])},da:function(a){return(a=nc[a])?t.isTexture(a):0},
ca:function(a){t.lineWidth(a)},ba:function(a){a=R[a];t.linkProgram(a);a.Dd=0;a.je={}},bc:function(a,b,c,d,e,f){t.ee.multiDrawArraysInstancedBaseInstanceWEBGL(a,C,b>>2,C,c>>2,C,d>>2,D,e>>2,f)},ac:function(a,b,c,d,e,f,g,h){t.ee.multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL(a,C,b>>2,c,C,d>>2,C,e>>2,C,f>>2,D,g>>2,h)},aa:function(a,b){3317==a&&(tc=b);t.pixelStorei(a,b)},cc:function(a){t.readBuffer(a)},$:function(a,b,c,d,e,f,g){if(2<=n.version)if(t.Rd)t.readPixels(a,b,c,d,e,f,g);else{var h=Hc(f);
t.readPixels(a,b,c,d,e,f,h,g>>31-Math.clz32(h.BYTES_PER_ELEMENT))}else(g=Ic(f,e,c,d,g))?t.readPixels(a,b,c,d,e,f,g):T(1280)},Lb:function(a,b,c,d){t.renderbufferStorage(a,b,c,d)},Ib:function(a,b,c,d,e){t.renderbufferStorageMultisample(a,b,c,d,e)},Bb:function(a,b,c){t.samplerParameteri(pc[a],b,c)},Ab:function(a,b,c){t.samplerParameteri(pc[a],b,C[c>>2])},_:function(a,b,c,d){t.scissor(a,b,c,d)},Z:function(a,b,c,d){for(var e="",f=0;f<b;++f){var g=d?C[d+4*f>>2]:-1,h=C[c+4*f>>2];g=h?Tb(A,h,0>g?void 0:g):
"";e+=g}t.shaderSource(S[a],e)},Y:function(a,b,c){t.stencilFunc(a,b,c)},X:function(a,b,c,d){t.stencilFuncSeparate(a,b,c,d)},W:function(a){t.stencilMask(a)},V:function(a,b){t.stencilMaskSeparate(a,b)},U:function(a,b,c){t.stencilOp(a,b,c)},T:function(a,b,c,d){t.stencilOpSeparate(a,b,c,d)},S:function(a,b,c,d,e,f,g,h,m){if(2<=n.version)if(t.zd)t.texImage2D(a,b,c,d,e,f,g,h,m);else if(m){var p=Hc(h);t.texImage2D(a,b,c,d,e,f,g,h,p,m>>31-Math.clz32(p.BYTES_PER_ELEMENT))}else t.texImage2D(a,b,c,d,e,f,g,h,
null);else t.texImage2D(a,b,c,d,e,f,g,h,m?Ic(h,g,d,e,m):null)},R:function(a,b,c){t.texParameterf(a,b,c)},Q:function(a,b,c){t.texParameterf(a,b,H[c>>2])},P:function(a,b,c){t.texParameteri(a,b,c)},O:function(a,b,c){t.texParameteri(a,b,C[c>>2])},_b:function(a,b,c,d,e){t.texStorage2D(a,b,c,d,e)},N:function(a,b,c,d,e,f,g,h,m){if(2<=n.version)if(t.zd)t.texSubImage2D(a,b,c,d,e,f,g,h,m);else if(m){var p=Hc(h);t.texSubImage2D(a,b,c,d,e,f,g,h,p,m>>31-Math.clz32(p.BYTES_PER_ELEMENT))}else t.texSubImage2D(a,
b,c,d,e,f,g,h,null);else p=null,m&&(p=Ic(h,g,e,f,m)),t.texSubImage2D(a,b,c,d,e,f,g,h,p)},M:function(a,b){t.uniform1f(U(a),b)},L:function(a,b,c){if(2<=n.version)b&&t.uniform1fv(U(a),H,c>>2,b);else{if(288>=b)for(var d=Jc[b-1],e=0;e<b;++e)d[e]=H[c+4*e>>2];else d=H.subarray(c>>2,c+4*b>>2);t.uniform1fv(U(a),d)}},K:function(a,b){t.uniform1i(U(a),b)},J:function(a,b,c){if(2<=n.version)b&&t.uniform1iv(U(a),C,c>>2,b);else{if(288>=b)for(var d=Kc[b-1],e=0;e<b;++e)d[e]=C[c+4*e>>2];else d=C.subarray(c>>2,c+4*b>>
2);t.uniform1iv(U(a),d)}},I:function(a,b,c){t.uniform2f(U(a),b,c)},H:function(a,b,c){if(2<=n.version)b&&t.uniform2fv(U(a),H,c>>2,2*b);else{if(144>=b)for(var d=Jc[2*b-1],e=0;e<2*b;e+=2)d[e]=H[c+4*e>>2],d[e+1]=H[c+(4*e+4)>>2];else d=H.subarray(c>>2,c+8*b>>2);t.uniform2fv(U(a),d)}},G:function(a,b,c){t.uniform2i(U(a),b,c)},Gc:function(a,b,c){if(2<=n.version)b&&t.uniform2iv(U(a),C,c>>2,2*b);else{if(144>=b)for(var d=Kc[2*b-1],e=0;e<2*b;e+=2)d[e]=C[c+4*e>>2],d[e+1]=C[c+(4*e+4)>>2];else d=C.subarray(c>>2,
c+8*b>>2);t.uniform2iv(U(a),d)}},Fc:function(a,b,c,d){t.uniform3f(U(a),b,c,d)},Ec:function(a,b,c){if(2<=n.version)b&&t.uniform3fv(U(a),H,c>>2,3*b);else{if(96>=b)for(var d=Jc[3*b-1],e=0;e<3*b;e+=3)d[e]=H[c+4*e>>2],d[e+1]=H[c+(4*e+4)>>2],d[e+2]=H[c+(4*e+8)>>2];else d=H.subarray(c>>2,c+12*b>>2);t.uniform3fv(U(a),d)}},Dc:function(a,b,c,d){t.uniform3i(U(a),b,c,d)},Cc:function(a,b,c){if(2<=n.version)b&&t.uniform3iv(U(a),C,c>>2,3*b);else{if(96>=b)for(var d=Kc[3*b-1],e=0;e<3*b;e+=3)d[e]=C[c+4*e>>2],d[e+1]=
C[c+(4*e+4)>>2],d[e+2]=C[c+(4*e+8)>>2];else d=C.subarray(c>>2,c+12*b>>2);t.uniform3iv(U(a),d)}},Bc:function(a,b,c,d,e){t.uniform4f(U(a),b,c,d,e)},Ac:function(a,b,c){if(2<=n.version)b&&t.uniform4fv(U(a),H,c>>2,4*b);else{if(72>=b){var d=Jc[4*b-1],e=H;c>>=2;for(var f=0;f<4*b;f+=4){var g=c+f;d[f]=e[g];d[f+1]=e[g+1];d[f+2]=e[g+2];d[f+3]=e[g+3]}}else d=H.subarray(c>>2,c+16*b>>2);t.uniform4fv(U(a),d)}},zc:function(a,b,c,d,e){t.uniform4i(U(a),b,c,d,e)},yc:function(a,b,c){if(2<=n.version)b&&t.uniform4iv(U(a),
C,c>>2,4*b);else{if(72>=b)for(var d=Kc[4*b-1],e=0;e<4*b;e+=4)d[e]=C[c+4*e>>2],d[e+1]=C[c+(4*e+4)>>2],d[e+2]=C[c+(4*e+8)>>2],d[e+3]=C[c+(4*e+12)>>2];else d=C.subarray(c>>2,c+16*b>>2);t.uniform4iv(U(a),d)}},xc:function(a,b,c,d){if(2<=n.version)b&&t.uniformMatrix2fv(U(a),!!c,H,d>>2,4*b);else{if(72>=b)for(var e=Jc[4*b-1],f=0;f<4*b;f+=4)e[f]=H[d+4*f>>2],e[f+1]=H[d+(4*f+4)>>2],e[f+2]=H[d+(4*f+8)>>2],e[f+3]=H[d+(4*f+12)>>2];else e=H.subarray(d>>2,d+16*b>>2);t.uniformMatrix2fv(U(a),!!c,e)}},wc:function(a,
b,c,d){if(2<=n.version)b&&t.uniformMatrix3fv(U(a),!!c,H,d>>2,9*b);else{if(32>=b)for(var e=Jc[9*b-1],f=0;f<9*b;f+=9)e[f]=H[d+4*f>>2],e[f+1]=H[d+(4*f+4)>>2],e[f+2]=H[d+(4*f+8)>>2],e[f+3]=H[d+(4*f+12)>>2],e[f+4]=H[d+(4*f+16)>>2],e[f+5]=H[d+(4*f+20)>>2],e[f+6]=H[d+(4*f+24)>>2],e[f+7]=H[d+(4*f+28)>>2],e[f+8]=H[d+(4*f+32)>>2];else e=H.subarray(d>>2,d+36*b>>2);t.uniformMatrix3fv(U(a),!!c,e)}},vc:function(a,b,c,d){if(2<=n.version)b&&t.uniformMatrix4fv(U(a),!!c,H,d>>2,16*b);else{if(18>=b){var e=Jc[16*b-1],
f=H;d>>=2;for(var g=0;g<16*b;g+=16){var h=d+g;e[g]=f[h];e[g+1]=f[h+1];e[g+2]=f[h+2];e[g+3]=f[h+3];e[g+4]=f[h+4];e[g+5]=f[h+5];e[g+6]=f[h+6];e[g+7]=f[h+7];e[g+8]=f[h+8];e[g+9]=f[h+9];e[g+10]=f[h+10];e[g+11]=f[h+11];e[g+12]=f[h+12];e[g+13]=f[h+13];e[g+14]=f[h+14];e[g+15]=f[h+15]}}else e=H.subarray(d>>2,d+64*b>>2);t.uniformMatrix4fv(U(a),!!c,e)}},uc:function(a){a=R[a];t.useProgram(a);t.re=a},tc:function(a,b){t.vertexAttrib1f(a,b)},sc:function(a,b){t.vertexAttrib2f(a,H[b>>2],H[b+4>>2])},rc:function(a,
b){t.vertexAttrib3f(a,H[b>>2],H[b+4>>2],H[b+8>>2])},qc:function(a,b){t.vertexAttrib4f(a,H[b>>2],H[b+4>>2],H[b+8>>2],H[b+12>>2])},Zb:function(a,b){t.vertexAttribDivisor(a,b)},Yb:function(a,b,c,d,e){t.vertexAttribIPointer(a,b,c,d,e)},pc:function(a,b,c,d,e,f){t.vertexAttribPointer(a,b,c,!!d,e,f)},oc:function(a,b,c,d){t.viewport(a,b,c,d)},Za:function(a,b,c,d){t.waitSync(qc[a],b,(c>>>0)+4294967296*d)},lb:a=>{var b=A.length;a>>>=0;if(2147483648<a)return!1;for(var c=1;4>=c;c*=2){var d=b*(1+.2/c);d=Math.min(d,
a+100663296);var e=Math;d=Math.max(a,d);a:{e=e.min.call(e,2147483648,d+(65536-d%65536)%65536)-sa.buffer.byteLength+65535>>>16;try{sa.grow(e);ya();var f=1;break a}catch(g){}f=void 0}if(f)return!0}return!1},ob:(a,b)=>{var c=0;Nc().forEach(function(d,e){var f=b+c;e=D[a+4*e>>2]=f;for(f=0;f<d.length;++f)ua[e++>>0]=d.charCodeAt(f);ua[e>>0]=0;c+=d.length+1});return 0},pb:(a,b)=>{var c=Nc();D[a>>2]=c.length;var d=0;c.forEach(function(e){d+=e.length+1});D[b>>2]=d;return 0},rb:()=>52,cb:function(){return 70},
qb:(a,b,c,d)=>{for(var e=0,f=0;f<c;f++){var g=D[b>>2],h=D[b+4>>2];b+=8;for(var m=0;m<h;m++){var p=A[g+m],r=Oc[a];0===p||10===p?((1===a?oa:pa)(Tb(r,0)),r.length=0):r.push(p)}e+=h}D[d>>2]=e;return 0},_a:vc,B:Dc,p:Yc,i:Zc,m:$c,u:ad,eb:bd,fb:cd,t:dd,l:ed,b:fd,d:gd,e:hd,C:jd,hb:kd,kb:(a,b,c,d)=>Tc(a,b,c,d)};
(function(){function a(c){y=c=c.exports;sa=y.Hc;ya();I=y.Nc;Aa.unshift(y.Ic);Da--;k.monitorRunDependencies&&k.monitorRunDependencies(Da);if(0==Da&&(null!==Ea&&(clearInterval(Ea),Ea=null),Fa)){var d=Fa;Fa=null;d()}return c}var b={a:ld};Da++;k.monitorRunDependencies&&k.monitorRunDependencies(Da);if(k.instantiateWasm)try{return k.instantiateWasm(b,a)}catch(c){pa("Module.instantiateWasm callback failed with error: "+c),ba(c)}Ma(b,function(c){a(c.instance)}).catch(ba);return{}})();
var Ec=a=>(Ec=y.Jc)(a),Eb=a=>(Eb=y.Kc)(a),Db=a=>(Db=y.Lc)(a);k.__embind_initialize_bindings=()=>(k.__embind_initialize_bindings=y.Mc)();var W=(a,b)=>(W=y.Oc)(a,b),X=()=>(X=y.Pc)(),Z=a=>(Z=y.Qc)(a);k.dynCall_iiiij=(a,b,c,d,e,f)=>(k.dynCall_iiiij=y.Rc)(a,b,c,d,e,f);k.dynCall_viiij=(a,b,c,d,e,f)=>(k.dynCall_viiij=y.Sc)(a,b,c,d,e,f);k.dynCall_iiij=(a,b,c,d,e)=>(k.dynCall_iiij=y.Tc)(a,b,c,d,e);k.dynCall_viij=(a,b,c,d,e)=>(k.dynCall_viij=y.Uc)(a,b,c,d,e);
k.dynCall_viiiiij=(a,b,c,d,e,f,g,h)=>(k.dynCall_viiiiij=y.Vc)(a,b,c,d,e,f,g,h);k.dynCall_jii=(a,b,c)=>(k.dynCall_jii=y.Wc)(a,b,c);k.dynCall_viji=(a,b,c,d,e)=>(k.dynCall_viji=y.Xc)(a,b,c,d,e);k.dynCall_ji=(a,b)=>(k.dynCall_ji=y.Yc)(a,b);k.dynCall_iij=(a,b,c,d)=>(k.dynCall_iij=y.Zc)(a,b,c,d);k.dynCall_vij=(a,b,c,d)=>(k.dynCall_vij=y._c)(a,b,c,d);k.dynCall_jiji=(a,b,c,d,e)=>(k.dynCall_jiji=y.$c)(a,b,c,d,e);k.dynCall_viijii=(a,b,c,d,e,f,g)=>(k.dynCall_viijii=y.ad)(a,b,c,d,e,f,g);
k.dynCall_iiiiij=(a,b,c,d,e,f,g)=>(k.dynCall_iiiiij=y.bd)(a,b,c,d,e,f,g);k.dynCall_iiiiijj=(a,b,c,d,e,f,g,h,m)=>(k.dynCall_iiiiijj=y.cd)(a,b,c,d,e,f,g,h,m);k.dynCall_iiiiiijj=(a,b,c,d,e,f,g,h,m,p)=>(k.dynCall_iiiiiijj=y.dd)(a,b,c,d,e,f,g,h,m,p);function fd(a,b,c){var d=X();try{I.get(a)(b,c)}catch(e){Z(d);if(e!==e+0)throw e;W(1,0)}}function $c(a,b,c,d){var e=X();try{return I.get(a)(b,c,d)}catch(f){Z(e);if(f!==f+0)throw f;W(1,0)}}
function hd(a,b,c,d,e){var f=X();try{I.get(a)(b,c,d,e)}catch(g){Z(f);if(g!==g+0)throw g;W(1,0)}}function ed(a,b){var c=X();try{I.get(a)(b)}catch(d){Z(c);if(d!==d+0)throw d;W(1,0)}}function Zc(a,b,c){var d=X();try{return I.get(a)(b,c)}catch(e){Z(d);if(e!==e+0)throw e;W(1,0)}}function ad(a,b,c,d,e){var f=X();try{return I.get(a)(b,c,d,e)}catch(g){Z(f);if(g!==g+0)throw g;W(1,0)}}function gd(a,b,c,d){var e=X();try{I.get(a)(b,c,d)}catch(f){Z(e);if(f!==f+0)throw f;W(1,0)}}
function Yc(a,b){var c=X();try{return I.get(a)(b)}catch(d){Z(c);if(d!==d+0)throw d;W(1,0)}}function dd(a){var b=X();try{I.get(a)()}catch(c){Z(b);if(c!==c+0)throw c;W(1,0)}}function kd(a,b,c,d,e,f,g,h,m){var p=X();try{I.get(a)(b,c,d,e,f,g,h,m)}catch(r){Z(p);if(r!==r+0)throw r;W(1,0)}}function cd(a,b,c,d,e,f,g){var h=X();try{return I.get(a)(b,c,d,e,f,g)}catch(m){Z(h);if(m!==m+0)throw m;W(1,0)}}
function bd(a,b,c,d,e,f){var g=X();try{return I.get(a)(b,c,d,e,f)}catch(h){Z(g);if(h!==h+0)throw h;W(1,0)}}function jd(a,b,c,d,e,f,g){var h=X();try{I.get(a)(b,c,d,e,f,g)}catch(m){Z(h);if(m!==m+0)throw m;W(1,0)}}var md;Fa=function nd(){md||od();md||(Fa=nd)};
function od(){function a(){if(!md&&(md=!0,k.calledRun=!0,!ta)){Na(Aa);aa(k);if(k.onRuntimeInitialized)k.onRuntimeInitialized();if(k.postRun)for("function"==typeof k.postRun&&(k.postRun=[k.postRun]);k.postRun.length;){var b=k.postRun.shift();Ba.unshift(b)}Na(Ba)}}if(!(0<Da)){if(k.preRun)for("function"==typeof k.preRun&&(k.preRun=[k.preRun]);k.preRun.length;)Ca();Na(za);0<Da||(k.setStatus?(k.setStatus("Running..."),setTimeout(function(){setTimeout(function(){k.setStatus("")},1);a()},1)):a())}}
if(k.preInit)for("function"==typeof k.preInit&&(k.preInit=[k.preInit]);0<k.preInit.length;)k.preInit.pop()();od();


  return moduleArg.ready
}

);
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rive);

/***/ }),
/* 2 */
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@rive-app/webgl","version":"2.3.1","description":"Rive\'s webgl based web api.","main":"rive.js","homepage":"https://rive.app","repository":{"type":"git","url":"https://github.com/rive-app/rive-wasm/tree/master/js"},"keywords":["rive","animation"],"author":"Rive","contributors":["Luigi Rosso <luigi@rive.app> (https://rive.app)","Maxwell Talbot <max@rive.app> (https://rive.app)","Arthur Vivian <arthur@rive.app> (https://rive.app)","Umberto Sonnino <umberto@rive.app> (https://rive.app)","Matthew Sullivan <matt.j.sullivan@gmail.com> (mailto:matt.j.sullivan@gmail.com)"],"license":"MIT","files":["rive.js","rive.wasm","rive.js.map","rive.d.ts","rive_advanced.mjs.d.ts"],"typings":"rive.d.ts","dependencies":{},"browser":{"fs":false,"path":false}}');

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerTouchInteractions: () => (/* reexport safe */ _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__.registerTouchInteractions)
/* harmony export */ });
/* harmony import */ var _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);



/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerTouchInteractions: () => (/* binding */ registerTouchInteractions)
/* harmony export */ });
var _this = undefined;
/**
 * Returns the clientX and clientY properties from touch or mouse events. Also
 * calls preventDefault() on the event if it is a touchstart or touchmove to prevent
 * scrolling the page on mobile devices
 * @param event - Either a TouchEvent or a MouseEvent
 * @returns - Coordinates of the clientX and clientY properties from the touch/mouse event
 */
var getClientCoordinates = function (event) {
    var _a, _b;
    if (["touchstart", "touchmove"].indexOf(event.type) > -1 &&
        ((_a = event.touches) === null || _a === void 0 ? void 0 : _a.length)) {
        event.preventDefault();
        return {
            clientX: event.touches[0].clientX,
            clientY: event.touches[0].clientY,
        };
    }
    else if (event.type === "touchend" &&
        ((_b = event.changedTouches) === null || _b === void 0 ? void 0 : _b.length)) {
        return {
            clientX: event.changedTouches[0].clientX,
            clientY: event.changedTouches[0].clientY,
        };
    }
    else {
        return {
            clientX: event.clientX,
            clientY: event.clientY,
        };
    }
};
/**
 * Registers mouse move/up/down callback handlers on the canvas to send meaningful coordinates to
 * the state machine pointer move/up/down functions based on cursor interaction
 */
var registerTouchInteractions = function (_a) {
    var canvas = _a.canvas, artboard = _a.artboard, _b = _a.stateMachines, stateMachines = _b === void 0 ? [] : _b, renderer = _a.renderer, rive = _a.rive, fit = _a.fit, alignment = _a.alignment;
    if (!canvas ||
        !stateMachines.length ||
        !renderer ||
        !rive ||
        !artboard ||
        typeof window === "undefined") {
        return null;
    }
    var processEventCallback = function (event) {
        var boundingRect = event.currentTarget.getBoundingClientRect();
        var _a = getClientCoordinates(event), clientX = _a.clientX, clientY = _a.clientY;
        if (!clientX && !clientY) {
            return;
        }
        var canvasX = clientX - boundingRect.left;
        var canvasY = clientY - boundingRect.top;
        var forwardMatrix = rive.computeAlignment(fit, alignment, {
            minX: 0,
            minY: 0,
            maxX: boundingRect.width,
            maxY: boundingRect.height,
        }, artboard.bounds);
        var invertedMatrix = new rive.Mat2D();
        forwardMatrix.invert(invertedMatrix);
        var canvasCoordinatesVector = new rive.Vec2D(canvasX, canvasY);
        var transformedVector = rive.mapXY(invertedMatrix, canvasCoordinatesVector);
        var transformedX = transformedVector.x();
        var transformedY = transformedVector.y();
        transformedVector.delete();
        invertedMatrix.delete();
        canvasCoordinatesVector.delete();
        forwardMatrix.delete();
        switch (event.type) {
            // Pointer moving/hovering on the canvas
            case "touchmove":
            case "mouseover":
            case "mouseout":
            case "mousemove": {
                for (var _i = 0, stateMachines_1 = stateMachines; _i < stateMachines_1.length; _i++) {
                    var stateMachine = stateMachines_1[_i];
                    stateMachine.pointerMove(transformedX, transformedY);
                }
                break;
            }
            // Pointer click initiated but not released yet on the canvas
            case "touchstart":
            case "mousedown": {
                for (var _b = 0, stateMachines_2 = stateMachines; _b < stateMachines_2.length; _b++) {
                    var stateMachine = stateMachines_2[_b];
                    stateMachine.pointerDown(transformedX, transformedY);
                }
                break;
            }
            // Pointer click released on the canvas
            case "touchend":
            case "mouseup": {
                for (var _c = 0, stateMachines_3 = stateMachines; _c < stateMachines_3.length; _c++) {
                    var stateMachine = stateMachines_3[_c];
                    stateMachine.pointerUp(transformedX, transformedY);
                }
                break;
            }
            default:
        }
    };
    var callback = processEventCallback.bind(_this);
    canvas.addEventListener("mouseover", callback);
    canvas.addEventListener("mouseout", callback);
    canvas.addEventListener("mousemove", callback);
    canvas.addEventListener("mousedown", callback);
    canvas.addEventListener("mouseup", callback);
    canvas.addEventListener("touchmove", callback);
    canvas.addEventListener("touchstart", callback);
    canvas.addEventListener("touchend", callback);
    return function () {
        canvas.removeEventListener("mouseover", callback);
        canvas.removeEventListener("mouseout", callback);
        canvas.removeEventListener("mousemove", callback);
        canvas.removeEventListener("mousedown", callback);
        canvas.removeEventListener("mouseup", callback);
        canvas.removeEventListener("touchmove", callback);
        canvas.removeEventListener("touchstart", callback);
        canvas.removeEventListener("touchend", callback);
    };
};


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alignment: () => (/* binding */ Alignment),
/* harmony export */   EventType: () => (/* binding */ EventType),
/* harmony export */   Fit: () => (/* binding */ Fit),
/* harmony export */   Layout: () => (/* binding */ Layout),
/* harmony export */   LoopType: () => (/* binding */ LoopType),
/* harmony export */   Rive: () => (/* binding */ Rive),
/* harmony export */   RuntimeLoader: () => (/* binding */ RuntimeLoader),
/* harmony export */   StateMachineInput: () => (/* binding */ StateMachineInput),
/* harmony export */   StateMachineInputType: () => (/* binding */ StateMachineInputType),
/* harmony export */   Testing: () => (/* binding */ Testing)
/* harmony export */ });
/* harmony import */ var _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var package_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



// #region layout
// Fit options for the canvas
var Fit;
(function (Fit) {
    Fit["Cover"] = "cover";
    Fit["Contain"] = "contain";
    Fit["Fill"] = "fill";
    Fit["FitWidth"] = "fitWidth";
    Fit["FitHeight"] = "fitHeight";
    Fit["None"] = "none";
    Fit["ScaleDown"] = "scaleDown";
})(Fit || (Fit = {}));
// Alignment options for the canvas
var Alignment;
(function (Alignment) {
    Alignment["Center"] = "center";
    Alignment["TopLeft"] = "topLeft";
    Alignment["TopCenter"] = "topCenter";
    Alignment["TopRight"] = "topRight";
    Alignment["CenterLeft"] = "centerLeft";
    Alignment["CenterRight"] = "centerRight";
    Alignment["BottomLeft"] = "bottomLeft";
    Alignment["BottomCenter"] = "bottomCenter";
    Alignment["BottomRight"] = "bottomRight";
})(Alignment || (Alignment = {}));
// Alignment options for Rive animations in a HTML canvas
var Layout = /** @class */ (function () {
    function Layout(params) {
        var _a, _b, _c, _d, _e, _f;
        this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : Fit.Contain;
        this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : Alignment.Center;
        this.minX = (_c = params === null || params === void 0 ? void 0 : params.minX) !== null && _c !== void 0 ? _c : 0;
        this.minY = (_d = params === null || params === void 0 ? void 0 : params.minY) !== null && _d !== void 0 ? _d : 0;
        this.maxX = (_e = params === null || params === void 0 ? void 0 : params.maxX) !== null && _e !== void 0 ? _e : 0;
        this.maxY = (_f = params === null || params === void 0 ? void 0 : params.maxY) !== null && _f !== void 0 ? _f : 0;
    }
    // Alternative constructor to build a Layout from an interface/object
    Layout.new = function (_a) {
        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
        console.warn("This function is deprecated: please use `new Layout({})` instead");
        return new Layout({ fit: fit, alignment: alignment, minX: minX, minY: minY, maxX: maxX, maxY: maxY });
    };
    /**
     * Makes a copy of the layout, replacing any specified parameters
     */
    Layout.prototype.copyWith = function (_a) {
        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;
        return new Layout({
            fit: fit !== null && fit !== void 0 ? fit : this.fit,
            alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,
            minX: minX !== null && minX !== void 0 ? minX : this.minX,
            minY: minY !== null && minY !== void 0 ? minY : this.minY,
            maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,
            maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY,
        });
    };
    // Returns fit for the Wasm runtime format
    Layout.prototype.runtimeFit = function (rive) {
        if (this.cachedRuntimeFit)
            return this.cachedRuntimeFit;
        var fit;
        if (this.fit === Fit.Cover)
            fit = rive.Fit.cover;
        else if (this.fit === Fit.Contain)
            fit = rive.Fit.contain;
        else if (this.fit === Fit.Fill)
            fit = rive.Fit.fill;
        else if (this.fit === Fit.FitWidth)
            fit = rive.Fit.fitWidth;
        else if (this.fit === Fit.FitHeight)
            fit = rive.Fit.fitHeight;
        else if (this.fit === Fit.ScaleDown)
            fit = rive.Fit.scaleDown;
        else
            fit = rive.Fit.none;
        this.cachedRuntimeFit = fit;
        return fit;
    };
    // Returns alignment for the Wasm runtime format
    Layout.prototype.runtimeAlignment = function (rive) {
        if (this.cachedRuntimeAlignment)
            return this.cachedRuntimeAlignment;
        var alignment;
        if (this.alignment === Alignment.TopLeft)
            alignment = rive.Alignment.topLeft;
        else if (this.alignment === Alignment.TopCenter)
            alignment = rive.Alignment.topCenter;
        else if (this.alignment === Alignment.TopRight)
            alignment = rive.Alignment.topRight;
        else if (this.alignment === Alignment.CenterLeft)
            alignment = rive.Alignment.centerLeft;
        else if (this.alignment === Alignment.CenterRight)
            alignment = rive.Alignment.centerRight;
        else if (this.alignment === Alignment.BottomLeft)
            alignment = rive.Alignment.bottomLeft;
        else if (this.alignment === Alignment.BottomCenter)
            alignment = rive.Alignment.bottomCenter;
        else if (this.alignment === Alignment.BottomRight)
            alignment = rive.Alignment.bottomRight;
        else
            alignment = rive.Alignment.center;
        this.cachedRuntimeAlignment = alignment;
        return alignment;
    };
    return Layout;
}());

// Runtime singleton; use getInstance to provide a callback that returns the
// Rive runtime
var RuntimeLoader = /** @class */ (function () {
    // Class is never instantiated
    function RuntimeLoader() {
    }
    // Loads the runtime
    RuntimeLoader.loadRuntime = function () {
        _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]({
            // Loads Wasm bundle
            locateFile: function () { return RuntimeLoader.wasmURL; },
        }).then(function (rive) {
            var _a;
            RuntimeLoader.runtime = rive;
            // Fire all the callbacks
            while (RuntimeLoader.callBackQueue.length > 0) {
                (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);
            }
        }).catch(function () {
            // In case unpkg fails or goes down, we should try to load from jsdelivr
            var backupJsdelivrUrl = "https://cdn.jsdelivr.net/npm/".concat(package_json__WEBPACK_IMPORTED_MODULE_1__.name, "@").concat(package_json__WEBPACK_IMPORTED_MODULE_1__.version, "/rive.wasm");
            if (RuntimeLoader.wasmURL.toLowerCase() !== backupJsdelivrUrl) {
                console.warn("Failed to load WASM from ".concat(RuntimeLoader.wasmURL, ", trying jsdelivr as a backup"));
                RuntimeLoader.setWasmUrl(backupJsdelivrUrl);
                RuntimeLoader.loadRuntime();
            }
            else {
                console.error("Could not load Rive WASM file from unpkg or jsdelivr, network connection may be down, or \
        you may need to call set a new WASM source via RuntimeLoader.setWasmUrl() and call \
        RuntimeLoader.loadRuntime() again");
            }
        });
    };
    // Provides a runtime instance via a callback
    RuntimeLoader.getInstance = function (callback) {
        // If it's not loading, start loading runtime
        if (!RuntimeLoader.isLoading) {
            RuntimeLoader.isLoading = true;
            RuntimeLoader.loadRuntime();
        }
        if (!RuntimeLoader.runtime) {
            RuntimeLoader.callBackQueue.push(callback);
        }
        else {
            callback(RuntimeLoader.runtime);
        }
    };
    // Provides a runtime instance via a promise
    RuntimeLoader.awaitInstance = function () {
        return new Promise(function (resolve) {
            return RuntimeLoader.getInstance(function (rive) { return resolve(rive); });
        });
    };
    // Manually sets the wasm url
    RuntimeLoader.setWasmUrl = function (url) {
        RuntimeLoader.wasmURL = url;
    };
    // Flag to indicate that loading has started/completed
    RuntimeLoader.isLoading = false;
    // List of callbacks for the runtime that come in while loading
    RuntimeLoader.callBackQueue = [];
    // Path to the Wasm file; default path works for testing only;
    // if embedded wasm is used then this is never used.
    RuntimeLoader.wasmURL = "https://unpkg.com/".concat(package_json__WEBPACK_IMPORTED_MODULE_1__.name, "@").concat(package_json__WEBPACK_IMPORTED_MODULE_1__.version, "/rive.wasm");
    return RuntimeLoader;
}());

// #endregion
// #region animations
// Wraps animations and instances from the runtime and keeps track of playback
// state
var Animation = /** @class */ (function () {
    /**
     * Constructs a new animation
     * @constructor
     * @param {any} animation: runtime animation object
     * @param {any} instance: runtime animation instance object
     */
    function Animation(animation, artboard, runtime, playing) {
        this.animation = animation;
        this.artboard = artboard;
        this.playing = playing;
        this.loopCount = 0;
        // Time to which the animation should move to on the next render
        this.scrubTo = null;
        this.instance = new runtime.LinearAnimationInstance(animation, artboard);
    }
    Object.defineProperty(Animation.prototype, "name", {
        // Returns the animation's name
        get: function () {
            return this.animation.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "time", {
        // Returns the animation's current time
        get: function () {
            return this.instance.time;
        },
        // Sets the animation's current time
        set: function (value) {
            this.instance.time = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "loopValue", {
        // Returns the animation's loop type
        get: function () {
            return this.animation.loopValue;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Advances the animation by the give time. If the animation needs scrubbing,
     * time is ignored and the stored scrub value is used.
     * @param time the time to advance the animation by if no scrubbing required
     */
    Animation.prototype.advance = function (time) {
        if (this.scrubTo === null) {
            this.instance.advance(time);
        }
        else {
            this.instance.time = 0;
            this.instance.advance(this.scrubTo);
            this.scrubTo = null;
        }
    };
    /**
     * Apply interpolated keyframe values to the artboard. This should be called after calling
     * .advance() on an animation instance so that new values are applied to properties.
     *
     * Note: This does not advance the artboard, which updates all objects on the artboard
     * @param mix - Mix value for the animation from 0 to 1
     */
    Animation.prototype.apply = function (mix) {
        this.instance.apply(mix);
    };
    Object.defineProperty(Animation.prototype, "needsScrub", {
        get: function () {
            return this.scrubTo !== null;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Deletes the backing Wasm animation instance; once this is called, this
     * animation is no more.
     */
    Animation.prototype.cleanup = function () {
        this.instance.delete();
    };
    return Animation;
}());
// #endregion
// #region state machines
var StateMachineInputType;
(function (StateMachineInputType) {
    StateMachineInputType[StateMachineInputType["Number"] = 56] = "Number";
    StateMachineInputType[StateMachineInputType["Trigger"] = 58] = "Trigger";
    StateMachineInputType[StateMachineInputType["Boolean"] = 59] = "Boolean";
})(StateMachineInputType || (StateMachineInputType = {}));
/**
 * An input for a state machine
 */
var StateMachineInput = /** @class */ (function () {
    function StateMachineInput(type, runtimeInput) {
        this.type = type;
        this.runtimeInput = runtimeInput;
    }
    Object.defineProperty(StateMachineInput.prototype, "name", {
        /**
         * Returns the name of the input
         */
        get: function () {
            return this.runtimeInput.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateMachineInput.prototype, "value", {
        /**
         * Returns the current value of the input
         */
        get: function () {
            return this.runtimeInput.value;
        },
        /**
         * Sets the value of the input
         */
        set: function (value) {
            this.runtimeInput.value = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Fires a trigger; does nothing on Number or Boolean input types
     */
    StateMachineInput.prototype.fire = function () {
        if (this.type === StateMachineInputType.Trigger) {
            this.runtimeInput.fire();
        }
    };
    return StateMachineInput;
}());

var StateMachine = /** @class */ (function () {
    /**
     * @constructor
     * @param stateMachine runtime state machine object
     * @param instance runtime state machine instance object
     */
    function StateMachine(stateMachine, runtime, playing, artboard) {
        this.stateMachine = stateMachine;
        this.playing = playing;
        this.artboard = artboard;
        /**
         * Caches the inputs from the runtime
         */
        this.inputs = [];
        this.instance = new runtime.StateMachineInstance(stateMachine, artboard);
        this.initInputs(runtime);
    }
    Object.defineProperty(StateMachine.prototype, "name", {
        get: function () {
            return this.stateMachine.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateMachine.prototype, "statesChanged", {
        /**
         * Returns a list of state names that have changed on this frame
         */
        get: function () {
            var names = [];
            for (var i = 0; i < this.instance.stateChangedCount(); i++) {
                names.push(this.instance.stateChangedNameByIndex(i));
            }
            return names;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Advances the state machine instance by a given time.
     * @param time - the time to advance the animation by in seconds
     */
    StateMachine.prototype.advance = function (time) {
        this.instance.advance(time);
    };
    /**
     * Fetches references to the state machine's inputs and caches them
     * @param runtime an instance of the runtime; needed for the SMIInput types
     */
    StateMachine.prototype.initInputs = function (runtime) {
        // Fetch the inputs from the runtime if we don't have them
        for (var i = 0; i < this.instance.inputCount(); i++) {
            var input = this.instance.input(i);
            this.inputs.push(this.mapRuntimeInput(input, runtime));
        }
    };
    /**
     * Maps a runtime input to it's appropriate type
     * @param input
     */
    StateMachine.prototype.mapRuntimeInput = function (input, runtime) {
        if (input.type === runtime.SMIInput.bool) {
            return new StateMachineInput(StateMachineInputType.Boolean, input.asBool());
        }
        else if (input.type === runtime.SMIInput.number) {
            return new StateMachineInput(StateMachineInputType.Number, input.asNumber());
        }
        else if (input.type === runtime.SMIInput.trigger) {
            return new StateMachineInput(StateMachineInputType.Trigger, input.asTrigger());
        }
    };
    /**
     * Deletes the backing Wasm state machine instance; once this is called, this
     * state machine is no more.
     */
    StateMachine.prototype.cleanup = function () {
        this.instance.delete();
    };
    return StateMachine;
}());
// #endregion
// #region animator
/**
 * Manages animation
 */
var Animator = /** @class */ (function () {
    /**
     * Constructs a new animator
     * @constructor
     * @param runtime Rive runtime; needed to instance animations & state machines
     * @param artboard the artboard that holds all animations and state machines
     * @param animations optional list of animations
     * @param stateMachines optional list of state machines
     */
    function Animator(runtime, artboard, eventManager, animations, stateMachines) {
        if (animations === void 0) { animations = []; }
        if (stateMachines === void 0) { stateMachines = []; }
        this.runtime = runtime;
        this.artboard = artboard;
        this.eventManager = eventManager;
        this.animations = animations;
        this.stateMachines = stateMachines;
    }
    /**
     * Adds animations and state machines by their names. If names are shared
     * between animations & state machines, then the first one found will be
     * created. Best not to use the same names for these in your Rive file.
     * @param animatable the name(s) of animations and state machines to add
     * @returns a list of names of the playing animations and state machines
     */
    Animator.prototype.add = function (animatables, playing, fireEvent) {
        if (fireEvent === void 0) { fireEvent = true; }
        animatables = mapToStringArray(animatables);
        // If animatables is empty, play or pause everything
        if (animatables.length === 0) {
            this.animations.forEach(function (a) { return (a.playing = playing); });
            this.stateMachines.forEach(function (m) { return (m.playing = playing); });
        }
        else {
            // Play/pause already instanced items, or create new instances
            var instancedAnimationNames = this.animations.map(function (a) { return a.name; });
            var instancedMachineNames = this.stateMachines.map(function (m) { return m.name; });
            for (var i = 0; i < animatables.length; i++) {
                var aIndex = instancedAnimationNames.indexOf(animatables[i]);
                var mIndex = instancedMachineNames.indexOf(animatables[i]);
                if (aIndex >= 0 || mIndex >= 0) {
                    if (aIndex >= 0) {
                        // Animation is instanced, play/pause it
                        this.animations[aIndex].playing = playing;
                    }
                    else {
                        // State machine is instanced, play/pause it
                        this.stateMachines[mIndex].playing = playing;
                    }
                }
                else {
                    // Try to create a new animation instance
                    var anim = this.artboard.animationByName(animatables[i]);
                    if (anim) {
                        var newAnimation = new Animation(anim, this.artboard, this.runtime, playing);
                        // Display the first frame of the specified animation
                        newAnimation.advance(0);
                        newAnimation.apply(1.0);
                        this.animations.push(newAnimation);
                    }
                    else {
                        // Try to create a new state machine instance
                        var sm = this.artboard.stateMachineByName(animatables[i]);
                        if (sm) {
                            var newStateMachine = new StateMachine(sm, this.runtime, playing, this.artboard);
                            this.stateMachines.push(newStateMachine);
                        }
                    }
                }
            }
        }
        // Fire play/paused events for animations
        if (fireEvent) {
            if (playing) {
                this.eventManager.fire({
                    type: EventType.Play,
                    data: this.playing,
                });
            }
            else {
                this.eventManager.fire({
                    type: EventType.Pause,
                    data: this.paused,
                });
            }
        }
        return playing ? this.playing : this.paused;
    };
    /**
     * Play the named animations/state machines
     * @param animatables the names of the animations/machines to play; plays all if empty
     * @returns a list of the playing items
     */
    Animator.prototype.play = function (animatables) {
        return this.add(animatables, true);
    };
    /**
     * Pauses named animations and state machines, or everything if nothing is
     * specified
     * @param animatables names of the animations and state machines to pause
     * @returns a list of names of the animations and state machines paused
     */
    Animator.prototype.pause = function (animatables) {
        return this.add(animatables, false);
    };
    /**
     * Set time of named animations
     * @param animations names of the animations to scrub
     * @param value time scrub value, a floating point number to which the playhead is jumped
     * @returns a list of names of the animations that were scrubbed
     */
    Animator.prototype.scrub = function (animatables, value) {
        var forScrubbing = this.animations.filter(function (a) {
            return animatables.includes(a.name);
        });
        forScrubbing.forEach(function (a) { return (a.scrubTo = value); });
        return forScrubbing.map(function (a) { return a.name; });
    };
    Object.defineProperty(Animator.prototype, "playing", {
        /**
         * Returns a list of names of all animations and state machines currently
         * playing
         */
        get: function () {
            return this.animations
                .filter(function (a) { return a.playing; })
                .map(function (a) { return a.name; })
                .concat(this.stateMachines.filter(function (m) { return m.playing; }).map(function (m) { return m.name; }));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "paused", {
        /**
         * Returns a list of names of all animations and state machines currently
         * paused
         */
        get: function () {
            return this.animations
                .filter(function (a) { return !a.playing; })
                .map(function (a) { return a.name; })
                .concat(this.stateMachines.filter(function (m) { return !m.playing; }).map(function (m) { return m.name; }));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Stops and removes all named animations and state machines
     * @param animatables animations and state machines to remove
     * @returns a list of names of removed items
     */
    Animator.prototype.stop = function (animatables) {
        var _this = this;
        animatables = mapToStringArray(animatables);
        // If nothing's specified, wipe them out, all of them
        var removedNames = [];
        // Stop everything
        if (animatables.length === 0) {
            removedNames = this.animations
                .map(function (a) { return a.name; })
                .concat(this.stateMachines.map(function (m) { return m.name; }));
            // Clean up before emptying the arrays
            this.animations.forEach(function (a) { return a.cleanup(); });
            this.stateMachines.forEach(function (m) { return m.cleanup(); });
            // Empty out the arrays
            this.animations.splice(0, this.animations.length);
            this.stateMachines.splice(0, this.stateMachines.length);
        }
        else {
            // Remove only the named animations/state machines
            var animationsToRemove = this.animations.filter(function (a) {
                return animatables.includes(a.name);
            });
            animationsToRemove.forEach(function (a) {
                a.cleanup();
                _this.animations.splice(_this.animations.indexOf(a), 1);
            });
            var machinesToRemove = this.stateMachines.filter(function (m) {
                return animatables.includes(m.name);
            });
            machinesToRemove.forEach(function (m) {
                m.cleanup();
                _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);
            });
            removedNames = animationsToRemove
                .map(function (a) { return a.name; })
                .concat(machinesToRemove.map(function (m) { return m.name; }));
        }
        this.eventManager.fire({
            type: EventType.Stop,
            data: removedNames,
        });
        // Return the list of animations removed
        return removedNames;
    };
    Object.defineProperty(Animator.prototype, "isPlaying", {
        /**
         * Returns true if at least one animation is active
         */
        get: function () {
            return (this.animations.reduce(function (acc, curr) { return acc || curr.playing; }, false) ||
                this.stateMachines.reduce(function (acc, curr) { return acc || curr.playing; }, false));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "isPaused", {
        /**
         * Returns true if all animations are paused and there's at least one animation
         */
        get: function () {
            return (!this.isPlaying &&
                (this.animations.length > 0 || this.stateMachines.length > 0));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animator.prototype, "isStopped", {
        /**
         * Returns true if there are no playing or paused animations/state machines
         */
        get: function () {
            return this.animations.length === 0 && this.stateMachines.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * If there are no animations or state machines, add the first one found
     * @returns the name of the animation or state machine instanced
     */
    Animator.prototype.atLeastOne = function (playing, fireEvent) {
        if (fireEvent === void 0) { fireEvent = true; }
        var instancedName;
        if (this.animations.length === 0 && this.stateMachines.length === 0) {
            if (this.artboard.animationCount() > 0) {
                // Add the first animation
                this.add([(instancedName = this.artboard.animationByIndex(0).name)], playing, fireEvent);
            }
            else if (this.artboard.stateMachineCount() > 0) {
                // Add the first state machine
                this.add([(instancedName = this.artboard.stateMachineByIndex(0).name)], playing, fireEvent);
            }
        }
        return instancedName;
    };
    /**
     * Checks if any animations have looped and if so, fire the appropriate event
     */
    Animator.prototype.handleLooping = function () {
        for (var _i = 0, _a = this.animations.filter(function (a) { return a.playing; }); _i < _a.length; _i++) {
            var animation = _a[_i];
            // Emit if the animation looped
            if (animation.loopValue === 0 && animation.loopCount) {
                animation.loopCount = 0;
                // This is a one-shot; if it has ended, delete the instance
                this.stop(animation.name);
            }
            else if (animation.loopValue === 1 && animation.loopCount) {
                this.eventManager.fire({
                    type: EventType.Loop,
                    data: { animation: animation.name, type: LoopType.Loop },
                });
                animation.loopCount = 0;
            }
            // Wasm indicates a loop at each time the animation
            // changes direction, so a full loop/lap occurs every
            // two loop counts
            else if (animation.loopValue === 2 && animation.loopCount > 1) {
                this.eventManager.fire({
                    type: EventType.Loop,
                    data: { animation: animation.name, type: LoopType.PingPong },
                });
                animation.loopCount = 0;
            }
        }
    };
    /**
     * Checks if states have changed in state machines and fires a statechange
     * event
     */
    Animator.prototype.handleStateChanges = function () {
        var statesChanged = [];
        for (var _i = 0, _a = this.stateMachines.filter(function (sm) { return sm.playing; }); _i < _a.length; _i++) {
            var stateMachine = _a[_i];
            statesChanged.push.apply(statesChanged, stateMachine.statesChanged);
        }
        if (statesChanged.length > 0) {
            this.eventManager.fire({
                type: EventType.StateChange,
                data: statesChanged,
            });
        }
    };
    Animator.prototype.handleAdvancing = function (time) {
        this.eventManager.fire({
            type: EventType.Advance,
            data: time,
        });
    };
    return Animator;
}());
// #endregion
// #region events
/**
 * Supported event types triggered in Rive
 */
var EventType;
(function (EventType) {
    EventType["Load"] = "load";
    EventType["LoadError"] = "loaderror";
    EventType["Play"] = "play";
    EventType["Pause"] = "pause";
    EventType["Stop"] = "stop";
    EventType["Loop"] = "loop";
    EventType["Draw"] = "draw";
    EventType["Advance"] = "advance";
    EventType["StateChange"] = "statechange";
})(EventType || (EventType = {}));
/**
 * Looping types: one-shot, loop, and ping-pong
 */
var LoopType;
(function (LoopType) {
    LoopType["OneShot"] = "oneshot";
    LoopType["Loop"] = "loop";
    LoopType["PingPong"] = "pingpong";
})(LoopType || (LoopType = {}));
// Manages Rive events and listeners
var EventManager = /** @class */ (function () {
    function EventManager(listeners) {
        if (listeners === void 0) { listeners = []; }
        this.listeners = listeners;
    }
    // Gets listeners of specified type
    EventManager.prototype.getListeners = function (type) {
        return this.listeners.filter(function (e) { return e.type === type; });
    };
    // Adds a listener
    EventManager.prototype.add = function (listener) {
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
        }
    };
    /**
     * Removes a listener
     * @param listener the listener with the callback to be removed
     */
    EventManager.prototype.remove = function (listener) {
        // We can't simply look for the listener as it'll be a different instance to
        // one originally subscribed. Find all the listeners of the right type and
        // then check their callbacks which should match.
        for (var i = 0; i < this.listeners.length; i++) {
            var currentListener = this.listeners[i];
            if (currentListener.type === listener.type) {
                if (currentListener.callback === listener.callback) {
                    this.listeners.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * Clears all listeners of specified type, or every listener if no type is
     * specified
     * @param type the type of listeners to clear, or all listeners if not
     * specified
     */
    EventManager.prototype.removeAll = function (type) {
        var _this = this;
        if (!type) {
            this.listeners.splice(0, this.listeners.length);
        }
        else {
            this.listeners
                .filter(function (l) { return l.type === type; })
                .forEach(function (l) { return _this.remove(l); });
        }
    };
    // Fires an event
    EventManager.prototype.fire = function (event) {
        var eventListeners = this.getListeners(event.type);
        eventListeners.forEach(function (listener) { return listener.callback(event); });
    };
    return EventManager;
}());
// Manages a queue of tasks
var TaskQueueManager = /** @class */ (function () {
    function TaskQueueManager(eventManager) {
        this.eventManager = eventManager;
        this.queue = [];
    }
    // Adds a task top the queue
    TaskQueueManager.prototype.add = function (task) {
        this.queue.push(task);
    };
    // Processes all tasks in the queue
    TaskQueueManager.prototype.process = function () {
        while (this.queue.length > 0) {
            var task = this.queue.shift();
            if (task === null || task === void 0 ? void 0 : task.action) {
                task.action();
            }
            if (task === null || task === void 0 ? void 0 : task.event) {
                this.eventManager.fire(task.event);
            }
        }
    };
    return TaskQueueManager;
}());
var Rive = /** @class */ (function () {
    function Rive(params) {
        var _a;
        // Tracks if a Rive file is loaded
        this.loaded = false;
        /**
         * Tracks if a Rive file is loaded; we need this in addition to loaded as some
         * commands (e.g. contents) can be called as soon as the file is loaded.
         * However, playback commands need to be queued and run in order once initial
         * animations and autoplay has been sorted out. This applies to play, pause,
         * and start.
         */
        this.readyForPlaying = false;
        // Runtime artboard
        this.artboard = null;
        // place to clear up event listeners
        this.eventCleanup = null;
        this.shouldDisableRiveListeners = false;
        // Durations to generate a frame for the last second. Used for performance profiling.
        this.durations = [];
        this.frameTimes = [];
        this.frameCount = 0;
        /**
         * Used be draw to track when a second of active rendering time has passed.
         * Used for debugging purposes
         */
        this.renderSecondTimer = 0;
        this.canvas = params.canvas;
        this.src = params.src;
        this.buffer = params.buffer;
        this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new Layout();
        this.shouldDisableRiveListeners = !!params.shouldDisableRiveListeners;
        // New event management system
        this.eventManager = new EventManager();
        if (params.onLoad)
            this.on(EventType.Load, params.onLoad);
        if (params.onLoadError)
            this.on(EventType.LoadError, params.onLoadError);
        if (params.onPlay)
            this.on(EventType.Play, params.onPlay);
        if (params.onPause)
            this.on(EventType.Pause, params.onPause);
        if (params.onStop)
            this.on(EventType.Stop, params.onStop);
        if (params.onLoop)
            this.on(EventType.Loop, params.onLoop);
        if (params.onStateChange)
            this.on(EventType.StateChange, params.onStateChange);
        if (params.onAdvance)
            this.on(EventType.Advance, params.onAdvance);
        /**
         * @deprecated Use camelCase'd versions instead.
         */
        if (params.onload && !params.onLoad)
            this.on(EventType.Load, params.onload);
        if (params.onloaderror && !params.onLoadError)
            this.on(EventType.LoadError, params.onloaderror);
        if (params.onplay && !params.onPlay)
            this.on(EventType.Play, params.onplay);
        if (params.onpause && !params.onPause)
            this.on(EventType.Pause, params.onpause);
        if (params.onstop && !params.onStop)
            this.on(EventType.Stop, params.onstop);
        if (params.onloop && !params.onLoop)
            this.on(EventType.Loop, params.onloop);
        if (params.onstatechange && !params.onStateChange)
            this.on(EventType.StateChange, params.onstatechange);
        // Hook up the task queue
        this.taskQueue = new TaskQueueManager(this.eventManager);
        this.init({
            src: this.src,
            buffer: this.buffer,
            autoplay: params.autoplay,
            animations: params.animations,
            stateMachines: params.stateMachines,
            artboard: params.artboard,
            useOffscreenRenderer: params.useOffscreenRenderer,
        });
    }
    // Alternative constructor to build a Rive instance from an interface/object
    Rive.new = function (params) {
        console.warn("This function is deprecated: please use `new Rive({})` instead");
        return new Rive(params);
    };
    // Initializes the Rive object either from constructor or load()
    Rive.prototype.init = function (_a) {
        var _this = this;
        var src = _a.src, buffer = _a.buffer, animations = _a.animations, stateMachines = _a.stateMachines, artboard = _a.artboard, _b = _a.autoplay, autoplay = _b === void 0 ? false : _b, _c = _a.useOffscreenRenderer, useOffscreenRenderer = _c === void 0 ? false : _c;
        this.src = src;
        this.buffer = buffer;
        // If no source file url specified, it's a bust
        if (!this.src && !this.buffer) {
            throw new Error(Rive.missingErrorMessage);
        }
        // List of animations that should be initialized.
        var startingAnimationNames = mapToStringArray(animations);
        // List of state machines that should be initialized
        var startingStateMachineNames = mapToStringArray(stateMachines);
        // Ensure loaded is marked as false if loading new file
        this.loaded = false;
        this.readyForPlaying = false;
        // Ensure the runtime is loaded
        RuntimeLoader.awaitInstance()
            .then(function (runtime) {
            _this.runtime = runtime;
            // Get the canvas where you want to render the animation and create a renderer
            _this.renderer = _this.runtime.makeRenderer(_this.canvas, useOffscreenRenderer);
            // Initial size adjustment based on devicePixelRatio if no width/height are
            // specified explicitly
            if (!(_this.canvas.width || _this.canvas.height)) {
                _this.resizeDrawingSurfaceToCanvas();
            }
            // Load Rive data from a source uri or a data buffer
            _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay)
                .then(function () { return _this.setupRiveListeners(); })
                .catch(function (e) {
                console.error(e);
            });
        })
            .catch(function (e) {
            console.error(e);
        });
    };
    Rive.prototype.setupRiveListeners = function () {
        var _this = this;
        if (!this.shouldDisableRiveListeners) {
            var activeStateMachines = (this.animator.stateMachines || [])
                .filter(function (sm) { return sm.playing && _this.runtime.hasListeners(sm.instance); })
                .map(function (sm) { return sm.instance; });
            this.eventCleanup = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.registerTouchInteractions)({
                canvas: this.canvas,
                artboard: this.artboard,
                stateMachines: activeStateMachines,
                renderer: this.renderer,
                rive: this.runtime,
                fit: this._layout.runtimeFit(this.runtime),
                alignment: this._layout.runtimeAlignment(this.runtime),
            });
        }
    };
    // Initializes runtime with Rive data and preps for playing
    Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, _c, msg;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!this.src) return [3 /*break*/, 2];
                        _b = this;
                        return [4 /*yield*/, loadRiveFile(this.src)];
                    case 1:
                        _b.buffer = _d.sent();
                        _d.label = 2;
                    case 2:
                        // Load the Rive file
                        _c = this;
                        return [4 /*yield*/, this.runtime.load(new Uint8Array(this.buffer))];
                    case 3:
                        // Load the Rive file
                        _c.file = _d.sent();
                        if (this.file) {
                            // Initialize and draw frame
                            this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay);
                            // Everything's set up, emit a load event
                            this.loaded = true;
                            this.eventManager.fire({
                                type: EventType.Load,
                                data: (_a = this.src) !== null && _a !== void 0 ? _a : "buffer",
                            });
                            // Flag ready for playback commands and clear the task queue; this order
                            // is important or it may infinitely recurse
                            this.readyForPlaying = true;
                            this.taskQueue.process();
                            this.drawFrame();
                            return [2 /*return*/, Promise.resolve()];
                        }
                        else {
                            msg = "Problem loading file; may be corrupt!";
                            console.warn(msg);
                            this.eventManager.fire({ type: EventType.LoadError, data: msg });
                            return [2 /*return*/, Promise.reject(msg)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // Initialize for playback
    Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay) {
        // Fetch the artboard
        var rootArtboard = artboardName
            ? this.file.artboardByName(artboardName)
            : this.file.defaultArtboard();
        // Check we have a working artboard
        if (!rootArtboard) {
            var msg = "Invalid artboard name or no default artboard";
            console.warn(msg);
            this.eventManager.fire({ type: EventType.LoadError, data: msg });
            return;
        }
        this.artboard = rootArtboard;
        // Check that the artboard has at least 1 animation
        if (this.artboard.animationCount() < 1) {
            var msg = "Artboard has no animations";
            this.eventManager.fire({ type: EventType.LoadError, data: msg });
            throw msg;
        }
        // Initialize the animator
        this.animator = new Animator(this.runtime, this.artboard, this.eventManager);
        // Initialize the animations; as loaded hasn't happened yet, we need to
        // suppress firing the play/pause events until the load event has fired. To
        // do this we tell the animator to suppress firing events, and add event
        // firing to the task queue.
        var instanceNames;
        if (animationNames.length > 0 || stateMachineNames.length > 0) {
            instanceNames = animationNames.concat(stateMachineNames);
            this.animator.add(instanceNames, autoplay, false);
        }
        else {
            instanceNames = [this.animator.atLeastOne(autoplay, false)];
        }
        // Queue up firing the playback events
        this.taskQueue.add({
            event: {
                type: autoplay ? EventType.Play : EventType.Pause,
                data: instanceNames,
            },
        });
    };
    // Draws the current artboard frame
    Rive.prototype.drawFrame = function () {
        this.startRendering();
    };
    /**
     * Draw rendering loop; renders animation frames at the correct time interval.
     * @param time the time at which to render a frame
     */
    Rive.prototype.draw = function (time, onSecond) {
        var before = performance.now();
        // Clear the frameRequestId, as we're now rendering a fresh frame
        this.frameRequestId = null;
        // On the first pass, make sure lastTime has a valid value
        if (!this.lastRenderTime) {
            this.lastRenderTime = time;
        }
        // Handle the onSecond callback
        this.renderSecondTimer += time - this.lastRenderTime;
        if (this.renderSecondTimer > 5000) {
            this.renderSecondTimer = 0;
            onSecond === null || onSecond === void 0 ? void 0 : onSecond();
        }
        // Calculate the elapsed time between frames in seconds
        var elapsedTime = (time - this.lastRenderTime) / 1000;
        this.lastRenderTime = time;
        // - Advance non-paused animations by the elapsed number of seconds
        // - Advance any animations that require scrubbing
        // - Advance to the first frame even when autoplay is false
        var activeAnimations = this.animator.animations
            .filter(function (a) { return a.playing || a.needsScrub; })
            // The scrubbed animations must be applied first to prevent weird artifacts
            // if the playing animations conflict with the scrubbed animating attribuates.
            .sort(function (first) { return (first.needsScrub ? -1 : 1); });
        for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {
            var animation = activeAnimations_1[_i];
            animation.advance(elapsedTime);
            if (animation.instance.didLoop) {
                animation.loopCount += 1;
            }
            animation.apply(1.0);
        }
        // - Advance non-paused state machines by the elapsed number of seconds
        // - Advance to the first frame even when autoplay is false
        var activeStateMachines = this.animator.stateMachines.filter(function (a) { return a.playing; });
        for (var _a = 0, activeStateMachines_1 = activeStateMachines; _a < activeStateMachines_1.length; _a++) {
            var stateMachine = activeStateMachines_1[_a];
            stateMachine.advance(elapsedTime);
            // stateMachine.instance.apply(this.artboard);
        }
        // Once the animations have been applied to the artboard, advance it
        // by the elapsed time.
        this.artboard.advance(elapsedTime);
        var renderer = this.renderer;
        // Canvas must be wiped to prevent artifacts
        renderer.clear();
        renderer.save();
        // Update the renderer alignment if necessary
        this.alignRenderer();
        this.artboard.draw(renderer);
        renderer.restore();
        renderer.flush();
        // Check for any animations that looped
        this.animator.handleLooping();
        // Check for any state machines that had a state change
        this.animator.handleStateChanges();
        // Report advanced time
        this.animator.handleAdvancing(elapsedTime);
        // Add duration to create frame to durations array
        this.frameCount++;
        var after = performance.now();
        this.frameTimes.push(after);
        this.durations.push(after - before);
        while (this.frameTimes[0] <= after - 1000) {
            this.frameTimes.shift();
            this.durations.shift();
        }
        // Calling requestAnimationFrame will rerun draw() at the correct rate:
        // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations
        if (this.animator.isPlaying) {
            // Request a new rendering frame
            this.startRendering();
        }
        else if (this.animator.isPaused) {
            // Reset the end time so on playback it starts at the correct frame
            this.lastRenderTime = 0;
        }
        else if (this.animator.isStopped) {
            // Reset animation instances, artboard and time
            // TODO: implement this properly when we have instancing
            // this.initArtboard();
            // this.drawFrame();
            this.lastRenderTime = 0;
        }
    };
    /**
     * Align the renderer
     */
    Rive.prototype.alignRenderer = function () {
        var _a = this, renderer = _a.renderer, runtime = _a.runtime, _layout = _a._layout, artboard = _a.artboard;
        // Align things up safe in the knowledge we can restore if changed
        renderer.align(_layout.runtimeFit(runtime), _layout.runtimeAlignment(runtime), {
            minX: _layout.minX,
            minY: _layout.minY,
            maxX: _layout.maxX,
            maxY: _layout.maxY,
        }, artboard.bounds);
    };
    Object.defineProperty(Rive.prototype, "fps", {
        get: function () {
            return this.durations.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "frameTime", {
        get: function () {
            if (this.durations.length === 0) {
                return 0;
            }
            return (this.durations.reduce(function (a, b) { return a + b; }, 0) / this.durations.length).toFixed(4);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Cleans up all Wasm-generated objects that need to be manually destroyed:
     * artboard instances, animation instances, state machine instances,
     * renderer instance, file and runtime.
     *
     * Once this is called, you will need to initialise a new instance of the
     * Rive class
     */
    Rive.prototype.cleanup = function () {
        var _a, _b;
        // Stop the renderer if it hasn't already been stopped.
        this.stopRendering();
        // Clean up any artboard, animation or state machine instances.
        this.cleanupInstances();
        // Delete the renderer
        (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.delete();
        this.renderer = null;
        // Delete the rive file
        (_b = this.file) === null || _b === void 0 ? void 0 : _b.delete();
        this.file = null;
    };
    /**
     * Cleans up any Wasm-generated objects that need to be manually destroyed:
     * artboard instances, animation instances, state machine instances.
     *
     * Once this is called, things will need to be reinitialized or bad things
     * might happen.
     */
    Rive.prototype.cleanupInstances = function () {
        if (this.eventCleanup !== null) {
            this.eventCleanup();
        }
        // Delete all animation and state machine instances
        this.stop();
        if (this.artboard) {
            this.artboard.delete();
            this.artboard = null;
        }
    };
    /**
     * Tries to query the setup Artboard for a text run node with the given name.
     *
     * @param textRunName - Name of the text run node associated with a text object
     * @returns - TextValueRun node or undefined if the text run cannot be queried
     */
    Rive.prototype.retrieveTextRun = function (textRunName) {
        var _a;
        if (!textRunName) {
            console.warn("No text run name provided");
            return;
        }
        if (!this.artboard) {
            console.warn("Tried to access text run, but the Artboard is null");
            return;
        }
        var textRun = this.artboard.textRun(textRunName);
        if (!textRun) {
            console.warn("Could not access a text run with name '".concat(textRunName, "' in the '").concat((_a = this.artboard) === null || _a === void 0 ? void 0 : _a.name, "' Artboard. Note that you must rename a text run node in the Rive editor to make it queryable at runtime."));
            return;
        }
        return textRun;
    };
    /**
     * Returns a string from a given text run node name, or undefined if the text run
     * cannot be queried.
     *
     * @param textRunName - Name of the text run node associated with a text object
     * @returns - String value of the text run node or undefined
     */
    Rive.prototype.getTextRunValue = function (textRunName) {
        var textRun = this.retrieveTextRun(textRunName);
        return textRun ? textRun.text : undefined;
    };
    /**
     * Sets a text value for a given text run node name if possible
     *
     * @param textRunName - Name of the text run node associated with a text object
     * @param textRunValue - String value to set on the text run node
     */
    Rive.prototype.setTextRunValue = function (textRunName, textRunValue) {
        var textRun = this.retrieveTextRun(textRunName);
        if (textRun) {
            textRun.text = textRunValue;
        }
    };
    // Plays specified animations; if none specified, it unpauses everything.
    Rive.prototype.play = function (animationNames, autoplay) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, queue up the play
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.play(animationNames, autoplay); },
            });
            return;
        }
        this.animator.play(animationNames);
        if (this.eventCleanup) {
            this.eventCleanup();
        }
        this.setupRiveListeners();
        this.startRendering();
    };
    // Pauses specified animations; if none specified, pauses all.
    Rive.prototype.pause = function (animationNames) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.pause(animationNames); },
            });
            return;
        }
        if (this.eventCleanup) {
            this.eventCleanup();
        }
        this.animator.pause(animationNames);
    };
    Rive.prototype.scrub = function (animationNames, value) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.scrub(animationNames, value); },
            });
            return;
        }
        // Scrub the animation time; we draw a single frame here so that if
        // nothing's currently playing, the scrubbed animation is still rendered/
        this.animator.scrub(animationNames, value || 0);
        this.drawFrame();
    };
    // Stops specified animations; if none specifies, stops them all.
    Rive.prototype.stop = function (animationNames) {
        var _this = this;
        animationNames = mapToStringArray(animationNames);
        // If the file's not loaded, early out, nothing to pause
        if (!this.readyForPlaying) {
            this.taskQueue.add({
                action: function () { return _this.stop(animationNames); },
            });
            return;
        }
        this.animator.stop(animationNames);
        if (this.eventCleanup) {
            this.eventCleanup();
        }
    };
    /**
     * Resets the animation
     * @param artboard the name of the artboard, or default if none given
     * @param animations the names of animations for playback
     * @param stateMachines the names of state machines for playback
     * @param autoplay whether to autoplay when reset, defaults to false
     *
     */
    Rive.prototype.reset = function (params) {
        var _a;
        // Get the current artboard, animations, state machines, and playback states
        var artBoardName = params === null || params === void 0 ? void 0 : params.artboard;
        var animationNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.animations);
        var stateMachineNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.stateMachines);
        var autoplay = (_a = params === null || params === void 0 ? void 0 : params.autoplay) !== null && _a !== void 0 ? _a : false;
        // Stop everything and clean up
        this.cleanupInstances();
        // Reinitialize an artboard instance with the state
        this.initArtboard(artBoardName, animationNames, stateMachineNames, autoplay);
        this.taskQueue.process();
    };
    // Loads a new Rive file, keeping listeners in place
    Rive.prototype.load = function (params) {
        // Stop all animations
        this.stop();
        // Reinitialize
        this.init(params);
    };
    Object.defineProperty(Rive.prototype, "layout", {
        /**
         * Returns the current layout. Note that layout should be treated as
         * immutable. If you want to change the layout, create a new one use the
         * layout setter
         */
        get: function () {
            return this._layout;
        },
        // Sets a new layout
        set: function (layout) {
            this._layout = layout;
            // If the maxX or maxY are 0, then set them to the canvas width and height
            if (!layout.maxX || !layout.maxY) {
                this.resizeToCanvas();
            }
            if (this.loaded && !this.animator.isPlaying) {
                this.drawFrame();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the layout bounds to the current canvas size; this is typically called
     * when the canvas is resized
     */
    Rive.prototype.resizeToCanvas = function () {
        this._layout = this.layout.copyWith({
            minX: 0,
            minY: 0,
            maxX: this.canvas.width,
            maxY: this.canvas.height,
        });
    };
    /**
     * Accounts for devicePixelRatio as a multiplier to render the size of the canvas drawing surface.
     * Uses the size of the backing canvas to set new width/height attributes. Need to re-render
     * and resize the layout to match the new drawing surface afterwards.
     * Useful function for consumers to include in a window resize listener
     */
    Rive.prototype.resizeDrawingSurfaceToCanvas = function () {
        if (this.canvas instanceof HTMLCanvasElement && !!window) {
            var _a = this.canvas.getBoundingClientRect(), width = _a.width, height = _a.height;
            var dpr = window.devicePixelRatio || 1;
            this.canvas.width = dpr * width;
            this.canvas.height = dpr * height;
            this.startRendering();
            this.resizeToCanvas();
        }
    };
    Object.defineProperty(Rive.prototype, "source", {
        // Returns the animation source, which may be undefined
        get: function () {
            return this.src;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "activeArtboard", {
        /**
         * Returns the name of the active artboard
         */
        get: function () {
            return this.artboard ? this.artboard.name : "";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "animationNames", {
        // Returns a list of animation names on the chosen artboard
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            var animationNames = [];
            for (var i = 0; i < this.artboard.animationCount(); i++) {
                animationNames.push(this.artboard.animationByIndex(i).name);
            }
            return animationNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "stateMachineNames", {
        /**
         * Returns a list of state machine names from the current artboard
         */
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            var stateMachineNames = [];
            for (var i = 0; i < this.artboard.stateMachineCount(); i++) {
                stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);
            }
            return stateMachineNames;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the inputs for the specified instanced state machine, or an empty
     * list if the name is invalid or the state machine is not instanced
     * @param name the state machine name
     * @returns the inputs for the named state machine
     */
    Rive.prototype.stateMachineInputs = function (name) {
        // If the file's not loaded, early out, nothing to pause
        if (!this.loaded) {
            return;
        }
        var stateMachine = this.animator.stateMachines.find(function (m) { return m.name === name; });
        return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;
    };
    Object.defineProperty(Rive.prototype, "playingStateMachineNames", {
        // Returns a list of playing machine names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.stateMachines
                .filter(function (m) { return m.playing; })
                .map(function (m) { return m.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "playingAnimationNames", {
        // Returns a list of playing animation names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.animations.filter(function (a) { return a.playing; }).map(function (a) { return a.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "pausedAnimationNames", {
        // Returns a list of paused animation names
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.animations
                .filter(function (a) { return !a.playing; })
                .map(function (a) { return a.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "pausedStateMachineNames", {
        /**
         *  Returns a list of paused machine names
         * @returns a list of state machine names that are paused
         */
        get: function () {
            // If the file's not loaded, we got nothing to return
            if (!this.loaded) {
                return [];
            }
            return this.animator.stateMachines
                .filter(function (m) { return !m.playing; })
                .map(function (m) { return m.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isPlaying", {
        /**
         * @returns true if any animation is playing
         */
        get: function () {
            return this.animator.isPlaying;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isPaused", {
        /**
         * @returns true if all instanced animations are paused
         */
        get: function () {
            return this.animator.isPaused;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "isStopped", {
        /**
         * @returns true if no animations are playing or paused
         */
        get: function () {
            return this.animator.isStopped;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rive.prototype, "bounds", {
        /**
         * @returns the bounds of the current artboard, or undefined if the artboard
         * isn't loaded yet.
         */
        get: function () {
            return this.artboard ? this.artboard.bounds : undefined;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Subscribe to Rive-generated events
     * @param type the type of event to subscribe to
     * @param callback callback to fire when the event occurs
     */
    Rive.prototype.on = function (type, callback) {
        this.eventManager.add({
            type: type,
            callback: callback,
        });
    };
    /**
     * Unsubscribes from a Rive-generated event
     * @param type the type of event to unsubscribe from
     * @param callback the callback to unsubscribe
     */
    Rive.prototype.off = function (type, callback) {
        this.eventManager.remove({
            type: type,
            callback: callback,
        });
    };
    /**
     * Unsubscribes from a Rive-generated event
     * @deprecated
     * @param callback the callback to unsubscribe from
     */
    Rive.prototype.unsubscribe = function (type, callback) {
        console.warn("This function is deprecated: please use `off()` instead.");
        this.off(type, callback);
    };
    /**
     * Unsubscribes all Rive listeners from an event type, or everything if no type is
     * given
     * @param type the type of event to unsubscribe from, or all types if
     * undefined
     */
    Rive.prototype.removeAllRiveEventListeners = function (type) {
        this.eventManager.removeAll(type);
    };
    /**
     * Unsubscribes all listeners from an event type, or everything if no type is
     * given
     * @deprecated
     * @param type the type of event to unsubscribe from, or all types if
     * undefined
     */
    Rive.prototype.unsubscribeAll = function (type) {
        console.warn("This function is deprecated: please use `removeAllRiveEventListeners()` instead.");
        this.removeAllRiveEventListeners(type);
    };
    /**
     * Stops the rendering loop; this is different from pausing in that it doesn't
     * change the state of any animation. It stops rendering from occurring. This
     * is designed for situations such as when Rive isn't visible.
     *
     * The only way to start rendering again is to call `startRendering`.
     * Animations that are marked as playing will start from the position that
     * they would have been at if rendering had not been stopped.
     */
    Rive.prototype.stopRendering = function () {
        if (this.loaded && this.frameRequestId) {
            if (this.runtime.cancelAnimationFrame) {
                this.runtime.cancelAnimationFrame(this.frameRequestId);
            }
            else {
                cancelAnimationFrame(this.frameRequestId);
            }
            this.frameRequestId = null;
        }
    };
    /**
     * Starts the rendering loop if it has been previously stopped. If the
     * renderer is already active, then this will have zero effect.
     */
    Rive.prototype.startRendering = function () {
        if (this.loaded && this.artboard && !this.frameRequestId) {
            if (this.runtime.requestAnimationFrame) {
                this.frameRequestId = this.runtime.requestAnimationFrame(this.draw.bind(this));
            }
            else {
                this.frameRequestId = requestAnimationFrame(this.draw.bind(this));
            }
        }
    };
    /**
     * Enables frames-per-second (FPS) reporting for the runtime
     * If no callback is provided, Rive will append a fixed-position div at the top-right corner of
     * the page with the FPS reading
     * @param fpsCallback - Callback from the runtime during the RAF loop that supplies the FPS value
     */
    Rive.prototype.enableFPSCounter = function (fpsCallback) {
        this.runtime.enableFPSCounter(fpsCallback);
    };
    /**
     * Disables frames-per-second (FPS) reporting for the runtime
     */
    Rive.prototype.disableFPSCounter = function () {
        this.runtime.disableFPSCounter();
    };
    Object.defineProperty(Rive.prototype, "contents", {
        /**
         * Returns the contents of a Rive file: the artboards, animations, and state machines
         */
        get: function () {
            if (!this.loaded) {
                return undefined;
            }
            var riveContents = {
                artboards: [],
            };
            for (var i = 0; i < this.file.artboardCount(); i++) {
                var artboard = this.file.artboardByIndex(i);
                var artboardContents = {
                    name: artboard.name,
                    animations: [],
                    stateMachines: [],
                };
                for (var j = 0; j < artboard.animationCount(); j++) {
                    var animation = artboard.animationByIndex(j);
                    artboardContents.animations.push(animation.name);
                }
                for (var k = 0; k < artboard.stateMachineCount(); k++) {
                    var stateMachine = artboard.stateMachineByIndex(k);
                    var name_1 = stateMachine.name;
                    var instance = new this.runtime.StateMachineInstance(stateMachine, artboard);
                    var inputContents = [];
                    for (var l = 0; l < instance.inputCount(); l++) {
                        var input = instance.input(l);
                        inputContents.push({ name: input.name, type: input.type });
                    }
                    artboardContents.stateMachines.push({
                        name: name_1,
                        inputs: inputContents,
                    });
                }
                riveContents.artboards.push(artboardContents);
            }
            return riveContents;
        },
        enumerable: false,
        configurable: true
    });
    // Error message for missing source or buffer
    Rive.missingErrorMessage = "Rive source file or data buffer required";
    return Rive;
}());

// Loads Rive data from a URI via fetch.
var loadRiveFile = function (src) { return __awaiter(void 0, void 0, void 0, function () {
    var req, res, buffer;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                req = new Request(src);
                return [4 /*yield*/, fetch(req)];
            case 1:
                res = _a.sent();
                return [4 /*yield*/, res.arrayBuffer()];
            case 2:
                buffer = _a.sent();
                return [2 /*return*/, buffer];
        }
    });
}); };
// #endregion
// #region utility functions
/*
 * Utility function to ensure an object is a string array
 */
var mapToStringArray = function (obj) {
    if (typeof obj === "string") {
        return [obj];
    }
    else if (obj instanceof Array) {
        return obj;
    }
    // If obj is undefined, return empty array
    return [];
};
// #endregion
// #region testing utilities
// Exports to only be used for tests
var Testing = {
    EventManager: EventManager,
    TaskQueueManager: TaskQueueManager,
};
// #endregion

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=rive.js.map